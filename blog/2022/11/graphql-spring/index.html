<!doctype html><html class=position-relative itemscope itemtype=https://schema.org/WebPage lang=zh-hans data-bs-theme=auto data-palette=purple><head><script src=/assets/init/bundle.min.d893010142cc6ee98760d32b7e1e90d3786505dcd396e888f1ee101971e02785.js integrity="sha256-2JMBAULMbumHYNMrfh6Q03hlBdzTluiI8e4QGXHgJ4U=" crossorigin=anonymous></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>graphql-spring -</title><link rel=icon href=/favicon_hucccd9e706a19cc8586335b155a80c266_43860_16x16_resize_q75_h2_box_2.webp sizes=16x16 type=image/webp><link rel=icon href=/favicon_hucccd9e706a19cc8586335b155a80c266_43860_32x32_resize_q75_h2_box_2.webp sizes=32x32 type=image/webp><link rel=icon href=/favicon_hucccd9e706a19cc8586335b155a80c266_43860_150x150_resize_q75_h2_box_2.webp sizes=150x150 type=image/webp><link rel=apple-touch-icon href=/favicon_hucccd9e706a19cc8586335b155a80c266_43860_180x180_resize_q75_h2_box_2.webp sizes=180x180 type=image/webp><link rel=icon href=/favicon_hucccd9e706a19cc8586335b155a80c266_43860_192x192_resize_q75_h2_box_2.webp sizes=192x192 type=image/webp><link rel=mask-icon href=/safari-pinned-tab.svg color=#6f42c1><meta name=keywords content="Hugo,Bootstrap,Blog Theme"><meta name=description content="注解驱动 Spring for GraphQL提供了一个基于注释的编程模型，其中@Controller组件使用注释来声明具有灵活方法签名的处理程序方法，以获取特定GraphQL字段的数据。例如：
@Controller public class GreetingController { @QueryMapping public String hello() { return &#34;Hello, world!&#34;; } } 将此方法绑定到查询，即查询类型下的字段。 如果未在注释上声明，则根据方法名确定查询。 Spring使用RuntimeWiring.Builder将上述处理程序方法注册为名为“hello”的查询graphql.schema.DataFetcher。
AnnotatedControllerConfigurer 检测 @Controller bean 并通过 RuntimeWiring.Builder 将标注的方法注册为 DataFetchers。 它是 RuntimeWiringConfigurer 的一个实现，可以添加到 GraphQlSource.Builder。 Spring Boot 自动将 AnnotatedControllerConfigurer 声明为 bean，并将所有 RuntimeWiringConfigurer bean 添加到 GraphQlSource.Builder 并启用对带注释的 DataFetchers 的支持。
@SchemaMapping @SchemaMapping 注解将方法映射到 GraphQL schema中的字段，并将其声明为该字段的 DataFetcher。 注解可以指定类型名称，以及字段名称：
@Controller public class BookController { @SchemaMapping(typeName=&#34;Book&#34;, field=&#34;author&#34;) public Author getAuthor(Book book) { // ... } } @SchemaMapping 注解也可以省略这些属性，在这种情况下，字段名称默认为方法名称，而类型名称默认为方法参数的简单类名称。 例如，下面默认键入Book和字段author："><meta name=twitter:card content="summary"><meta name=twitter:title content="graphql-spring"><meta name=twitter:description content="注解驱动 Spring for GraphQL提供了一个基于注释的编程模型，其中@Controller组件使用注释来声明具有灵活方法签名的处理程序方法，以获取特定GraphQL字段的数据。例如：
@Controller public class GreetingController { @QueryMapping public String hello() { return &#34;Hello, world!&#34;; } } 将此方法绑定到查询，即查询类型下的字段。 如果未在注释上声明，则根据方法名确定查询。 Spring使用RuntimeWiring.Builder将上述处理程序方法注册为名为“hello”的查询graphql.schema.DataFetcher。
AnnotatedControllerConfigurer 检测 @Controller bean 并通过 RuntimeWiring.Builder 将标注的方法注册为 DataFetchers。 它是 RuntimeWiringConfigurer 的一个实现，可以添加到 GraphQlSource.Builder。 Spring Boot 自动将 AnnotatedControllerConfigurer 声明为 bean，并将所有 RuntimeWiringConfigurer bean 添加到 GraphQlSource.Builder 并启用对带注释的 DataFetchers 的支持。
@SchemaMapping @SchemaMapping 注解将方法映射到 GraphQL schema中的字段，并将其声明为该字段的 DataFetcher。 注解可以指定类型名称，以及字段名称：
@Controller public class BookController { @SchemaMapping(typeName=&#34;Book&#34;, field=&#34;author&#34;) public Author getAuthor(Book book) { // ... } } @SchemaMapping 注解也可以省略这些属性，在这种情况下，字段名称默认为方法名称，而类型名称默认为方法参数的简单类名称。 例如，下面默认键入Book和字段author："><meta property="og:title" content="graphql-spring"><meta property="og:description" content="注解驱动 Spring for GraphQL提供了一个基于注释的编程模型，其中@Controller组件使用注释来声明具有灵活方法签名的处理程序方法，以获取特定GraphQL字段的数据。例如：
@Controller public class GreetingController { @QueryMapping public String hello() { return &#34;Hello, world!&#34;; } } 将此方法绑定到查询，即查询类型下的字段。 如果未在注释上声明，则根据方法名确定查询。 Spring使用RuntimeWiring.Builder将上述处理程序方法注册为名为“hello”的查询graphql.schema.DataFetcher。
AnnotatedControllerConfigurer 检测 @Controller bean 并通过 RuntimeWiring.Builder 将标注的方法注册为 DataFetchers。 它是 RuntimeWiringConfigurer 的一个实现，可以添加到 GraphQlSource.Builder。 Spring Boot 自动将 AnnotatedControllerConfigurer 声明为 bean，并将所有 RuntimeWiringConfigurer bean 添加到 GraphQlSource.Builder 并启用对带注释的 DataFetchers 的支持。
@SchemaMapping @SchemaMapping 注解将方法映射到 GraphQL schema中的字段，并将其声明为该字段的 DataFetcher。 注解可以指定类型名称，以及字段名称：
@Controller public class BookController { @SchemaMapping(typeName=&#34;Book&#34;, field=&#34;author&#34;) public Author getAuthor(Book book) { // ... } } @SchemaMapping 注解也可以省略这些属性，在这种情况下，字段名称默认为方法名称，而类型名称默认为方法参数的简单类名称。 例如，下面默认键入Book和字段author："><meta property="og:type" content="article"><meta property="og:url" content="https://banrenshan.github.io/blog/2022/11/graphql-spring/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-11-27T19:02:13+00:00"><meta property="article:modified_time" content="2023-10-07T19:19:27+08:00"><meta itemprop=name content="graphql-spring"><meta itemprop=description content="注解驱动 Spring for GraphQL提供了一个基于注释的编程模型，其中@Controller组件使用注释来声明具有灵活方法签名的处理程序方法，以获取特定GraphQL字段的数据。例如：
@Controller public class GreetingController { @QueryMapping public String hello() { return &#34;Hello, world!&#34;; } } 将此方法绑定到查询，即查询类型下的字段。 如果未在注释上声明，则根据方法名确定查询。 Spring使用RuntimeWiring.Builder将上述处理程序方法注册为名为“hello”的查询graphql.schema.DataFetcher。
AnnotatedControllerConfigurer 检测 @Controller bean 并通过 RuntimeWiring.Builder 将标注的方法注册为 DataFetchers。 它是 RuntimeWiringConfigurer 的一个实现，可以添加到 GraphQlSource.Builder。 Spring Boot 自动将 AnnotatedControllerConfigurer 声明为 bean，并将所有 RuntimeWiringConfigurer bean 添加到 GraphQlSource.Builder 并启用对带注释的 DataFetchers 的支持。
@SchemaMapping @SchemaMapping 注解将方法映射到 GraphQL schema中的字段，并将其声明为该字段的 DataFetcher。 注解可以指定类型名称，以及字段名称：
@Controller public class BookController { @SchemaMapping(typeName=&#34;Book&#34;, field=&#34;author&#34;) public Author getAuthor(Book book) { // ... } } @SchemaMapping 注解也可以省略这些属性，在这种情况下，字段名称默认为方法名称，而类型名称默认为方法参数的简单类名称。 例如，下面默认键入Book和字段author："><meta itemprop=datePublished content="2022-11-27T19:02:13+00:00"><meta itemprop=dateModified content="2023-10-07T19:19:27+08:00"><meta itemprop=wordCount content="1541"><meta itemprop=keywords content="java,spring,graphql,"><meta property="og:image" content="https://banrenshan.github.io/images/logo.png"><meta name=twitter:image content="https://banrenshan.github.io/images/logo.png"><meta property="og:image:alt" content="graphql-spring"><meta name=twitter:image:alt content="graphql-spring"><link rel=manifest href=/manifest.json><link data-precache rel=stylesheet href="/assets/main/bundle.min.906e48a4015f207e7ad2852421d4b8e6fda8fb5c6d1fff31855591474e60da12.css" integrity="sha256-kG5IpAFfIH560oUkIdS45v2o+1xtH/8xhVWRR05g2hI=" crossorigin=anonymous><link data-precache rel=stylesheet href=/assets/viewer/bundle.min.eb914844636cd41f221f109e99c887bbc3b6b5ffb2af7c664b284cea2d1b54b7.css integrity="sha256-65FIRGNs1B8iHxCemciHu8O2tf+yr3xmSyhM6i0bVLc=" crossorigin=anonymous></head><body><header class="mb-4 sticky-top"><nav class="top-app-bar shadow navbar navbar-expand-xxl"><div class=container><a class="navbar-brand d-flex align-items-center flex-grow-1 flex-xxl-grow-0 justify-content-xxl-start ms-2 ms-xxl-0 mx-auto me-xxl-2" href=https://banrenshan.github.io/><picture><img class=logo alt=Logo src=https://banrenshan.github.io/images/logo.webp loading=lazy width=400 height=400></picture></a><div class="offcanvas-xxl offcanvas-end flex-grow-1" data-bs-scroll=true tabindex=-1 id=navbarMenus aria-labelledby=navbarMenusLabel><div class="offcanvas-header px-4 pb-0"><div class="offcanvas-title h5" id=navbarMenusLabel></div><button type=button class="btn-close btn-close-white" data-bs-dismiss=offcanvas data-bs-target=#navbarMenus aria-label=Close></button></div><div class="offcanvas-body p-4 pt-0 p-xxl-0"><hr class=d-xxl-none><ul class="navbar-nav flex-row flex-wrap align-items-center me-auto"><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/docs/><span class="menu-icon me-1"><i class="fas fa-fw fa-book"></i></span>文档</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/series/><span class="menu-icon me-1"><i class="fas fa-fw fa-columns"></i></span>专栏</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/categories/><span class="menu-icon me-1"><i class="fas fa-fw fa-folder"></i></span>分类</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/archives/><span class="menu-icon me-1"><i class="fas fa-fw fa-file-archive"></i></span>归档</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/tags/><span class="menu-icon me-1"><i class="fas fa-fw fa-tags"></i></span>标签</a></li></ul><hr class=d-xxl-none><form class="search-bar ms-auto my-auto" action=/search/ novalidate><div class="input-group input-group-sm align-items-center"><span class="btn btn-search disabled position-absolute left-0 border-0 px-1"><i class="fas fa-fw fa-search fa-lg"></i></span>
<input class="my-1 form-control border-white rounded-5 search-input bg-body" name=q type=search placeholder=搜索 aria-label=Search required>
<span class="search-shortcut position-absolute end-0 top-0 me-2"><kbd class="bg-primary rounded shadow">/</kbd></span></div></form><hr class=d-xxl-none><ul class="navbar-nav flex-row flex-wrap align-items-center ms-md-auto"><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=fontSizeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-font"></i>
<span class=d-xxl-none>字体大小</span></a><ul class="font-size-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=fontSizeDropdown><li><button class="font-size-item dropdown-item" data-size=xs>
特小号</button></li><li><button class="font-size-item dropdown-item" data-size=sm>
小号</button></li><li><button class="font-size-item dropdown-item active" data-size=md>
中等</button></li><li><button class="font-size-item dropdown-item" data-size=lg>
大号</button></li><li><button class="font-size-item dropdown-item" data-size=xl>
特大号</button></li></ul></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=paletteDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-palette"></i>
<span class=d-xxl-none>配色</span></a><ul class="palette-dropdown-menu dropdown-menu dropdown-menu-end px-2 row g-2" aria-labelledby=paletteDropdown><li class="col-4 my-1"><a role=button id=palette-blue aria-label=蓝色 class="btn btn-sm w-100 palette text-bg-blue" data-palette=blue></a></li><li class="col-4 my-1"><a role=button id=palette-blue-gray aria-label=蓝灰色 class="btn btn-sm w-100 palette text-bg-blue-gray" data-palette=blue-gray></a></li><li class="col-4 my-1"><a role=button id=palette-brown aria-label=棕色 class="btn btn-sm w-100 palette text-bg-brown" data-palette=brown></a></li><li class="col-4 my-1"><a role=button id=palette-cyan aria-label=青色 class="btn btn-sm w-100 palette text-bg-cyan" data-palette=cyan></a></li><li class="col-4 my-1"><a role=button id=palette-green aria-label=绿色 class="btn btn-sm w-100 palette text-bg-green" data-palette=green></a></li><li class="col-4 my-1"><a role=button id=palette-indigo aria-label=靛青色 class="btn btn-sm w-100 palette text-bg-indigo" data-palette=indigo></a></li><li class="col-4 my-1"><a role=button id=palette-orange aria-label=橙色 class="btn btn-sm w-100 palette text-bg-orange" data-palette=orange></a></li><li class="col-4 my-1"><a role=button id=palette-pink aria-label=粉色 class="btn btn-sm w-100 palette text-bg-pink" data-palette=pink></a></li><li class="col-4 my-1"><a role=button id=palette-purple aria-label=紫色 class="btn btn-sm w-100 palette text-bg-purple" data-palette=purple></a></li><li class="col-4 my-1"><a role=button id=palette-red aria-label=红色 class="btn btn-sm w-100 palette text-bg-red" data-palette=red></a></li><li class="col-4 my-1"><a role=button id=palette-teal aria-label=蓝绿色 class="btn btn-sm w-100 palette text-bg-teal" data-palette=teal></a></li><li class="col-4 my-1"><a role=button id=palette-yellow aria-label=黄色 class="btn btn-sm w-100 palette text-bg-yellow" data-palette=yellow></a></li></ul></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=modeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="mode-icon fas fa-fw fa-adjust" id=modeIcon></i>
<span class=d-xxl-none>模式</span></a><ul class="mode-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=modeDropdown><li class=mode-item data-color-mode=light data-icon=sun><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-sun"></i> 浅色</button></li><li class=mode-item data-color-mode=dark data-icon=moon><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-moon"></i> 深色</button></li><li class="mode-item active" data-color-mode=auto data-icon=adjust><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-adjust"></i> 自动</button></li></ul></li></ul></div></div><div class=d-flex><button class="navbar-toggler order-5 border-0" type=button data-bs-toggle=offcanvas data-bs-target=#navbarMenus aria-controls=navbarMenus aria-expanded=false aria-label="Toggle navigation">
<i class="fas fa-ellipsis-h"></i></button></div></div></nav></header><main class=container><div class="row content"><noscript><div class="alert alert-danger" role=alert>你的浏览器不支持 JavaScript。</div></noscript><div class=col-xxl-8><div class=container><nav class="row card component" aria-label=breadcrumb><div class="card-body pb-0"><ol class="hbs-breadcrumb breadcrumb flex-nowrap"><li class="breadcrumb-item text-surface"><a href=/>主页</a></li><li class="breadcrumb-item text-surface"><a href=/blog/>Blogs</a></li><li class="breadcrumb-item active">Graphql-Spring</li></ol></div></nav><div class="post-panel-wrapper position-relative d-flex justify-content-center"><div class="d-flex flex-row justify-content-center rounded-5 border post-panel position-fixed px-3 py-1 surface shadow-1"><a class="action action-toc d-none d-xxl-block" href=#postTOC role=button title="Table of contents"><i class="fas fa-fw fa-list-alt"></i></a>
<a class="action action-toc d-block d-xxl-none" href=#post-toc-container role=button title="Table of contents"><i class="fas fa-fw fa-list-alt"></i></a>
<a class="action action-post-comments" href=#post-comments role=button aria-label=Comments title=Comments><i class="fas fa-fw fa-comments"></i></a>
<a id=sidebarToggler class="action action-sidebar-toggler d-none d-xxl-block" role=button title="Sidebar toggler"><i class="fas fa-fw fa-expand-alt" data-fa-transform=rotate-45></i></a></div></div><article class="row card component mb-4 post"><div class=card-header><h1 class="card-title post-title my-2">Graphql-Spring</h1></div><div class=card-body><div class="post-meta mb-3"><span class="post-date me-1 mb-1" title="创建于 2022-11-27 19:02:13 +0000 UTC，更新于 2023-10-07 11:19:27 +0000 UTC。">2022年11月27日</span><span class="post-reading-time me-1 mb-1">8 分钟阅读</span><a href=/categories/java/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-category">
<i class="fas fa-fw fa-folder me-1"></i>Java</a><a href=/tags/graphql/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">Graphql</a><a href=/tags/java/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">Java</a><a href=/tags/spring/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">Spring</a></div><div class="mt-2 mb-3 d-block d-xxl-none"><h2 class="text-surface mb-3">目录</h2><div id=post-toc-container></div><hr class=text-secondary></div><div class="post-content mb-3" data-bs-spy=scroll data-bs-target=#TableOfContents tabindex=0><div id=post-content-body><h1 id=注解驱动 data-numberify>注解驱动<a class="anchor ms-1" href=#注解驱动></a></h1><p>Spring for GraphQL提供了一个基于注释的编程模型，其中@Controller组件使用注释来声明具有灵活方法签名的处理程序方法，以获取特定GraphQL字段的数据。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>class</span> <span class=nc>GreetingController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@QueryMapping</span> 
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>String</span> <span class=nf>hello</span><span class=o>()</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s>&#34;Hello, world!&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><ol><li>将此方法绑定到查询，即查询类型下的字段。</li><li>如果未在注释上声明，则根据方法名确定查询。</li></ol><p>Spring使用RuntimeWiring.Builder将上述处理程序方法注册为名为“hello”的查询graphql.schema.DataFetcher。</p><p><picture><img class=img-fluid alt=img src loading=lazy></picture></p><p>AnnotatedControllerConfigurer 检测 @Controller bean 并通过 RuntimeWiring.Builder 将标注的方法注册为 DataFetchers。 它是 RuntimeWiringConfigurer 的一个实现，可以添加到 GraphQlSource.Builder。 Spring Boot 自动将 AnnotatedControllerConfigurer 声明为 bean，并将所有 RuntimeWiringConfigurer bean 添加到 GraphQlSource.Builder 并启用对带注释的 DataFetchers 的支持。</p><h2 id=schemamapping data-numberify>@SchemaMapping<a class="anchor ms-1" href=#schemamapping></a></h2><p>@SchemaMapping 注解将方法映射到 GraphQL schema中的字段，并将其声明为该字段的 DataFetcher。 注解可以指定类型名称，以及字段名称：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@SchemaMapping</span><span class=o>(</span><span class=n>typeName</span><span class=o>=</span><span class=s>&#34;Book&#34;</span><span class=o>,</span> <span class=n>field</span><span class=o>=</span><span class=s>&#34;author&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Author</span> <span class=nf>getAuthor</span><span class=o>(</span><span class=n>Book</span> <span class=n>book</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>@SchemaMapping 注解也可以省略这些属性，在这种情况下，字段名称默认为方法名称，而类型名称默认为方法参数的简单类名称。 例如，下面默认键入Book和字段author：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@SchemaMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Author</span> <span class=nf>author</span><span class=o>(</span><span class=n>Book</span> <span class=n>book</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>@SchemaMapping 注解可以在类级别声明，为类中的所有处理程序方法指定默认类型名称:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=nd>@SchemaMapping</span><span class=o>(</span><span class=n>typeName</span><span class=o>=</span><span class=s>&#34;Book&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// @SchemaMapping methods for fields of the &#34;Book&#34; type
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>@QueryMapping、@MutationMapping 和@SubscriptionMapping 是复合注解，它们本身使用@SchemaMapping 进行标注，并且typeName 分别预设为Query、Mutation 或Subscription。</p><h3 id=方法签名 data-numberify>方法签名<a class="anchor ms-1" href=#方法签名></a></h3><p>schema映射处理程序方法可以具有以下任何方法参数：</p><table><thead><tr><th>Method Argument</th><th>Description</th></tr></thead><tbody><tr><td>@Argument</td><td>用于访问绑定到更高级别、类型化对象的命名字段参数。</td></tr><tr><td>@Arguments</td><td>用于访问绑定到更高级别、类型化对象的所有字段参数。</td></tr><tr><td>@Argument Map&lt;String, Object></td><td>用于访问参数的原始map，其中@Argument没有name属性。</td></tr><tr><td>@Arguments Map&lt;String, Object></td><td>用于访问参数的原始映射。</td></tr><tr><td>@ProjectedPayload Interface</td><td>用于通过项目接口访问字段参数。</td></tr><tr><td>&ldquo;Source&rdquo;</td><td>用于访问字段的源（即父/容器）实例。</td></tr><tr><td>DataLoader</td><td>用于访问DataLoaderRegistry中的DataLoader。</td></tr><tr><td>@ContextValue</td><td>用于从DataFetchingEnvironment中的主GraphQLContext访问属性。</td></tr><tr><td>@LocalContextValue</td><td>用于从DataFetchingEnvironment中的本地GraphQLContext访问属性。</td></tr><tr><td>GraphQLContext</td><td>用于从DataFetchingEnvironment访问上下文。</td></tr><tr><td>java.security.Principal</td><td>从Spring Security上下文中获取（如果可用）。</td></tr><tr><td>@AuthenticationPrincipal</td><td>从Spring Security上下文访问Authentication#getPrincipal（）。</td></tr><tr><td>DataFetchingFieldSelectionSet</td><td>通过DataFetchingEnvironment访问查询的选择集。</td></tr><tr><td>Locale, Optional</td><td>用于从DataFetchingEnvironment访问区域设置。</td></tr><tr><td>DataFetchingEnvironment</td><td>用于直接访问基础DataFetchingEnvironment。</td></tr></tbody></table><p>schema映射处理程序方法可以返回：</p><ul><li>任何类型的解析值。</li><li>Mono 和Flux 用于异步值。 支持控制器方法和响应式 DataFetcher 中描述的任何 DataFetcher。</li><li>java.util.concurrent.Callable 以异步方式生成值。 为此，必须使用 Executor 配置 AnnotatedControllerConfigurer。</li></ul><h3 id=argument data-numberify>@Argument<a class="anchor ms-1" href=#argument></a></h3><p>在 GraphQL Java 中，DataFetchingEnvironment 提供了对特定字段的参数值映射的访问。 这些值可以是简单的标量值（例如 String、Long）、用于更复杂输入的Map 或列表。</p><p>使用 @Argument 注释将参数绑定到目标对象并注入到处理程序方法中。 绑定是通过将参数值映射到预期方法参数类型的主数据构造函数来执行的，或者通过使用默认构造函数来创建对象，然后将参数值映射到它的属性。 这是递归重复的，使用所有嵌套的参数值并相应地创建嵌套的目标对象。 例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>query</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>bookById</span><span class=o>(</span><span class=n>id</span><span class=o>:</span> <span class=s>&#34;book-1&#34;</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>id</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=n>author</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>id</span>
</span></span><span class=line><span class=cl>      <span class=n>lastName</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=n>type</span> <span class=n>Query</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>bookById</span><span class=o>(</span><span class=n>id</span><span class=o>:</span><span class=n>String</span><span class=o>):</span><span class=n>Book</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@QueryMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Book</span> <span class=nf>bookById</span><span class=o>(</span><span class=nd>@Argument</span> <span class=n>String</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@MutationMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Book</span> <span class=nf>addBook</span><span class=o>(</span><span class=nd>@Argument</span> <span class=n>BookInput</span> <span class=n>bookInput</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>默认情况下，如果方法参数名称可用，则它用于查找参数。 如果需要，您可以通过注解自定义名称，例如 @Argument(&ldquo;bookInput&rdquo;)。</p><p>如果绑定失败，则会引发 BindException，绑定问题累积为字段错误，其中每个错误的字段是发生问题的参数路径。</p><p>您可以将 @Argument 与 Map&lt;String, Object> 参数一起使用，以获取所有参数值的原始映射。 不得设置 @Argument 上的 name 属性。</p><h3 id=arguments data-numberify>@Arguments<a class="anchor ms-1" href=#arguments></a></h3><p>@Arguments 绑定参数到对象类型，而 @Argument 则绑定到简单参数。</p><p>例如，@Argument BookInput bookInput 使用参数“bookInput”的值来初始化 BookInput对象。</p><p>您可以将 @Arguments 与 Map&lt;String, Object> 参数一起使用，以获取所有参数值的原始映射。</p><h3 id=projectedpayload data-numberify>@ProjectedPayload<a class="anchor ms-1" href=#projectedpayload></a></h3><p>当 Spring Data 在类路径上时，参数投影由 Spring Data 的接口投影提供。</p><p>要使用它，请创建一个使用 @ProjectedPayload 注释的接口并将其声明为控制器方法参数。 如果参数使用@Argument 进行注释，则它适用于 DataFetchingEnvironment.getArguments() 映射中的单个参数。 在没有 @Argument 的情况下声明时，投影适用于完整参数映射中的顶级参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@QueryMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Book</span> <span class=nf>bookById</span><span class=o>(</span><span class=n>BookIdProjection</span> <span class=n>bookId</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@MutationMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Book</span> <span class=nf>addBook</span><span class=o>(</span><span class=nd>@Argument</span> <span class=n>BookInputProjection</span> <span class=n>bookInput</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@ProjectedPayload</span>
</span></span><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>BookIdProjection</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Long</span> <span class=nf>getId</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@ProjectedPayload</span>
</span></span><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>BookInputProjection</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Value</span><span class=o>(</span><span class=s>&#34;#{target.author + &#39; &#39; + target.name}&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>getAuthorAndName</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=source data-numberify>Source<a class="anchor ms-1" href=#source></a></h3><p>在 GraphQL Java 中，DataFetchingEnvironment 提供对字段源（即父/容器）实例的访问。 要访问它，只需声明预期目标类型的方法参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@SchemaMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Author</span> <span class=nf>author</span><span class=o>(</span><span class=n>Book</span> <span class=n>book</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>源方法参数还有助于确定映射的类型名称。 如果 Java 类的简单名称与 GraphQL 类型匹配，则无需在 @SchemaMapping 注解中显式指定类型名称。</p><h3 id=dataloader data-numberify>DataLoader<a class="anchor ms-1" href=#dataloader></a></h3><p>当您为实体注册批量加载功能时，如批量加载中所述，您可以通过声明 DataLoader 类型的方法参数来访问实体的 DataLoader 并使用它来加载实体：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>BookController</span><span class=o>(</span><span class=n>BatchLoaderRegistry</span> <span class=n>registry</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>registry</span><span class=o>.</span><span class=na>forTypePair</span><span class=o>(</span><span class=n>Long</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=n>Author</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>registerMappedBatchLoader</span><span class=o>((</span><span class=n>authorIds</span><span class=o>,</span> <span class=n>env</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// return Map&lt;Long, Author&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@SchemaMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Author</span><span class=o>&gt;</span> <span class=nf>author</span><span class=o>(</span><span class=n>Book</span> <span class=n>book</span><span class=o>,</span> <span class=n>DataLoader</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=n>Author</span><span class=o>&gt;</span> <span class=n>loader</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>loader</span><span class=o>.</span><span class=na>load</span><span class=o>(</span><span class=n>book</span><span class=o>.</span><span class=na>getAuthorId</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>默认情况下，BatchLoaderRegistry 使用值类型的完整类名（例如 Author 的类名）作为注册键，因此只需使用泛型类型声明 DataLoader 方法参数即可提供足够的信息来在 DataLoaderRegistry 中定位它。 作为后备，DataLoader 方法参数解析器还将尝试将方法参数名称作为键，但通常这不是必需的。</p><p>请注意，对于许多加载相关实体的情况，@SchemaMapping 只是委托给 DataLoader，您可以使用下一节中描述的 @BatchMapping 方法来减少样板。</p><h3 id=validation data-numberify>Validation<a class="anchor ms-1" href=#validation></a></h3><p>当找到 javax.validation.Validator bean 时，AnnotatedControllerConfigurer 启用对带注释的控制器方法的 Bean Validation 的支持。 通常，bean 的类型为 LocalValidatorFactoryBean。</p><p>Bean 验证允许您声明类型的约束：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookInput</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@NotNull</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>title</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@NotNull</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Size</span><span class=o>(</span><span class=n>max</span><span class=o>=</span><span class=mi>13</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>isbn</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>然后，您可以使用 @Valid 注释控制器方法参数以在方法调用之前对其进行验证：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@MutationMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Book</span> <span class=nf>addBook</span><span class=o>(</span><span class=nd>@Argument</span> <span class=nd>@Valid</span> <span class=n>BookInput</span> <span class=n>bookInput</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>如果在验证期间发生错误，则会引发 ConstraintViolationException。 您可以使用异常解决链来决定如何将其转换为错误以包含在 GraphQL 响应中，从而将其呈现给客户端。</p><p>Bean 验证对@Argument、@Arguments 和@ProjectedPayload 方法参数很有用，但更普遍地适用于任何方法参数。</p><h2 id=batchmapping data-numberify>@BatchMapping<a class="anchor ms-1" href=#batchmapping></a></h2><p>批量加载通过使用 org.dataloader.DataLoader 延迟加载单个实体实例来解决 N+1 选择问题，因此它们可以一起加载。 例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>BookController</span><span class=o>(</span><span class=n>BatchLoaderRegistry</span> <span class=n>registry</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>registry</span><span class=o>.</span><span class=na>forTypePair</span><span class=o>(</span><span class=n>Long</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=n>Author</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>registerMappedBatchLoader</span><span class=o>((</span><span class=n>authorIds</span><span class=o>,</span> <span class=n>env</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// return Map&lt;Long, Author&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@SchemaMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>CompletableFuture</span><span class=o>&lt;</span><span class=n>Author</span><span class=o>&gt;</span> <span class=nf>author</span><span class=o>(</span><span class=n>Book</span> <span class=n>book</span><span class=o>,</span> <span class=n>DataLoader</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=n>Author</span><span class=o>&gt;</span> <span class=n>loader</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>loader</span><span class=o>.</span><span class=na>load</span><span class=o>(</span><span class=n>book</span><span class=o>.</span><span class=na>getAuthorId</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>对于加载关联实体的直接情况，如上所示，@SchemaMapping 方法只是委托给 DataLoader。 这是可以通过 @BatchMapping 方法避免的样板。 例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BookController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@BatchMapping</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Mono</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>Book</span><span class=o>,</span> <span class=n>Author</span><span class=o>&gt;&gt;</span> <span class=nf>author</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Book</span><span class=o>&gt;</span> <span class=n>books</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>以上成为 BatchLoaderRegistry 中的批量加载函数，其中键是 Book 实例，加载的值是它们的作者。 此外，DataFetcher 也透明地绑定到 Book 类型的 author 字段，它只是为作者委托 DataLoader，给定它的源/父 Book 实例。</p><p>默认情况下，字段名默认为方法名，而类型名默认为输入List元素类型的简单类名。 两者都可以通过注释属性进行自定义。 类型名称也可以从类级别@SchemaMapping 继承。</p><h1 id=数据集成 data-numberify>数据集成<a class="anchor ms-1" href=#数据集成></a></h1><p>Spring for GraphQL 允许您利用现有的 Spring 技术，遵循常见的编程模型公开底层数据源。</p><p>本节讨论 Spring Data 的集成层，它提供了一种将 Querydsl 或 Query by Example 存储库适应 DataFetcher 的简单方法，包括自动检测选项和标记为 @GraphQlRepository 的存储库的 GraphQL 查询注册。</p><h2 id=querydsl data-numberify>Querydsl<a class="anchor ms-1" href=#querydsl></a></h2><p>Spring for GraphQL 支持使用 Querydsl ，通过 Spring Data Querydsl 扩展来获取数据。 Querydsl 通过使用注释处理器生成元模型，提供了一种灵活但类型安全的方法来表达查询谓词。</p><p>例如，将存储库声明为 QuerydslPredicateExecutor：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>AccountRepository</span> <span class=kd>extends</span> <span class=n>Repository</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>,</span> <span class=n>Long</span><span class=o>&gt;,</span>
</span></span><span class=line><span class=cl>            <span class=n>QuerydslPredicateExecutor</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>然后用它来创建一个DataFetcher：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// For single result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QuerydslDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>single</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// For multi-result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>&gt;&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QuerydslDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>many</span><span class=o>();</span>
</span></span></code></pre></div><p>现在可以通过 RuntimeWiringConfigurer 注册上述 DataFetcher。</p><p>DataFetcher 从 GraphQL 请求参数构建一个 Querydsl 谓词，并使用它来获取数据。 Spring Data 支持 JPA、MongoDB 和 LDAP 的 QuerydslPredicateExecutor。</p><p>如果存储库是 ReactiveQuerydslPredicateExecutor，则构建器返回 DataFetcher&lt;Mono> 或 DataFetcher&lt;Flux>。 Spring Data MongoDB 支持这种变体。</p><h3 id=构建 data-numberify>构建<a class="anchor ms-1" href=#构建></a></h3><p>要在您的构建中配置 Querydsl，请遵循<a href=https://querydsl.com/static/querydsl/latest/reference/html/ch02.html target=_blank rel="noopener noreferrer">官方参考文档<i class="fas fa-external-link-square-alt ms-1"></i></a>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>dependencies</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>annotationProcessor</span> <span class=s>&#34;com.querydsl:querydsl-apt:$querydslVersion:jpa&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>            <span class=err>&#39;</span><span class=n>org</span><span class=o>.</span><span class=na>hibernate</span><span class=o>.</span><span class=na>javax</span><span class=o>.</span><span class=na>persistence</span><span class=o>:</span><span class=n>hibernate</span><span class=o>-</span><span class=n>jpa</span><span class=o>-</span><span class=mi>2</span><span class=o>.</span><span class=na>1</span><span class=o>-</span><span class=n>api</span><span class=o>:</span><span class=mi>1</span><span class=o>.</span><span class=na>0</span><span class=o>.</span><span class=na>2</span><span class=o>.</span><span class=na>Final</span><span class=err>&#39;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>            <span class=err>&#39;</span><span class=n>javax</span><span class=o>.</span><span class=na>annotation</span><span class=o>:</span><span class=n>javax</span><span class=o>.</span><span class=na>annotation</span><span class=o>-</span><span class=n>api</span><span class=o>:</span><span class=mi>1</span><span class=o>.</span><span class=na>3</span><span class=o>.</span><span class=na>2</span><span class=err>&#39;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>compileJava</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>     <span class=n>options</span><span class=o>.</span><span class=na>annotationProcessorPath</span> <span class=o>=</span> <span class=n>configurations</span><span class=o>.</span><span class=na>annotationProcessor</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><a href=https://github.com/spring-projects/spring-graphql/tree/main/samples/webmvc-http target=_blank rel="noopener noreferrer">webmvc-http<i class="fas fa-external-link-square-alt ms-1"></i></a> 示例将 Querydsl 用于 artifactRepositories。</p><h3 id=自定义 data-numberify>自定义<a class="anchor ms-1" href=#自定义></a></h3><p>QuerydslDataFetcher 支持自定义 GraphQL 参数如何绑定到属性以创建 Querydsl 谓词。 默认情况下，每个可用属性的参数都绑定为“等于”。 要自定义它，您可以使用 QuerydslDataFetcher 构建器方法来提供 QuerydslBinderCustomizer。</p><p>存储库本身可能是 QuerydslBinderCustomizer 的一个实例。 这是在自动注册期间自动检测并透明应用的。 但是，当手动构建 QuerydslDataFetcher 时，您将需要使用构建器方法来应用它。</p><p>QuerydslDataFetcher 支持接口和 DTO 投影来转换查询结果，然后再返回这些结果以进行进一步的 GraphQL 处理。</p><p>要将 Spring Data 投影与 Querydsl 存储库一起使用，请创建投影接口或目标 DTO 类，并通过 projectAs 方法对其进行配置，以获得生成目标类型的 DataFetcher：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Account</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=n>identifier</span><span class=o>,</span> <span class=n>description</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=n>owner</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>AccountProjection</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>getIdentifier</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// For single result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>AccountProjection</span><span class=o>&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QuerydslDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>projectAs</span><span class=o>(</span><span class=n>AccountProjection</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>single</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// For multi-result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>AccountProjection</span><span class=o>&gt;&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QuerydslDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>projectAs</span><span class=o>(</span><span class=n>AccountProjection</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>many</span><span class=o>();</span>
</span></span></code></pre></div><h3 id=自动注册 data-numberify>自动注册<a class="anchor ms-1" href=#自动注册></a></h3><p>如果存储库使用@GraphQlRepository 进行注释，则会自动为尚未注册 DataFetcher 且返回类型与存储库域类型匹配的查询注册。 这包括单值和多值查询。</p><p>默认情况下，查询返回的 GraphQL 类型的名称必须与存储库域类型的简单名称匹配。 如果需要，您可以使用 @GraphQlRepository 的 typeName 属性来指定目标 GraphQL 类型名称。</p><p>自动注册检测给定存储库是否实现 QuerydslBinderCustomizer 并通过 QuerydslDataFetcher 构建器方法透明地应用它。</p><p>自动注册是通过可从 QuerydslDataFetcher 获得的内置 RuntimeWiringConfigurer 执行的。 Boot 启动器会自动检测 @GraphQlRepository bean 并使用它们来初始化 RuntimeWiringConfigurer。</p><p>自动注册不支持自定义。 如果需要，您需要使用 QueryByExampleDataFetcher 通过 RuntimeWiringConfigurer 手动构建和注册 DataFetcher。</p><h2 id=query-by-example data-numberify>Query by Example<a class="anchor ms-1" href=#query-by-example></a></h2><p>Spring Data 支持使用 Query by Example 来获取数据。 Query by Example (QBE) 是一种简单的查询技术，不需要您通过特定于store的查询语言编写查询。</p><p>首先声明一个存储库 QueryByExampleExecutor：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>AccountRepository</span> <span class=kd>extends</span> <span class=n>Repository</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>,</span> <span class=n>Long</span><span class=o>&gt;,</span>
</span></span><span class=line><span class=cl>            <span class=n>QueryByExampleExecutor</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>使用 QueryByExampleDataFetcher 将存储库转换为 DataFecher：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// For single result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QueryByExampleDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>single</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// For multi-result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Account</span><span class=o>&gt;&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QueryByExampleDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>many</span><span class=o>();</span>
</span></span></code></pre></div><p>现在可以通过 RuntimeWiringConfigurer 注册上述 DataFetcher。</p><p>DataFetcher 使用 GraphQL 参数映射来创建存储库的域类型，并将其用作示例对象来获取数据。 Spring Data 支持 JPA、MongoDB、Neo4j 和 Redis 的 QueryByExampleDataFetcher。</p><p>如果存储库是 ReactiveQueryByExampleExecutor，则构建器返回 DataFetcher&lt;Mono> 或 DataFetcher&lt;Flux>。 Spring Data 支持 MongoDB、Neo4j、Redis 和 R2dbc 的这种变体。</p><p>QueryByExampleDataFetcher 支持接口和 DTO 投影来转换查询结果，然后再返回这些结果以进行进一步的 GraphQL 处理。</p><p>要将 Spring Data 投影与 Query by Example 存储库一起使用，请创建投影接口或目标 DTO 类，并通过 projectAs 方法对其进行配置，以获得生成目标类型的 DataFetcher：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Account</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=n>identifier</span><span class=o>,</span> <span class=n>description</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=n>owner</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>AccountProjection</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>getIdentifier</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// For single result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>AccountProjection</span><span class=o>&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QueryByExampleDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>projectAs</span><span class=o>(</span><span class=n>AccountProjection</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>single</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// For multi-result queries
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DataFetcher</span><span class=o>&lt;</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>AccountProjection</span><span class=o>&gt;&gt;</span> <span class=n>dataFetcher</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>QueryByExampleDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>projectAs</span><span class=o>(</span><span class=n>AccountProjection</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>many</span><span class=o>();</span>
</span></span></code></pre></div><p>如果存储库使用@GraphQlRepository 进行注释，则会自动为尚未注册 DataFetcher 且返回类型与存储库域类型匹配的查询注册。 这包括单值和多值查询。</p><p>默认情况下，查询返回的 GraphQL 类型的名称必须与存储库域类型的简单名称匹配。 如果需要，您可以使用 @GraphQlRepository 的 typeName 属性来指定目标 GraphQL 类型名称。</p><p>自动注册是通过可从 QueryByExampleDataFetcher 获得的内置 RuntimeWiringConfigurer 执行的。 Boot 启动器会自动检测 @GraphQlRepository bean 并使用它们来初始化 RuntimeWiringConfigurer。</p><p>自动注册不支持自定义。 如果需要，您需要使用 QueryByExampleDataFetcher 通过 RuntimeWiringConfigurer 手动构建和注册 DataFetcher。</p><h1 id=服务器传输 data-numberify>服务器传输<a class="anchor ms-1" href=#服务器传输></a></h1><p>GraphQL后端支持三种协议：HTTP , WebSocket 和 RSocket.</p><h2 id=http data-numberify>HTTP<a class="anchor ms-1" href=#http></a></h2><p>GraphQlHttpHandler接受GraphQl请求，并委托给拦截链处理请求。 有两个变体，一个用于Spring MVC，另一个用于Spring WebFlux。 两者都异步处理请求，并且具有等效的功能，但是分别依靠阻塞和非阻塞I/O编写HTTP响应。</p><p>GraphQL必须使用POST请求，请求体使用json格式。一旦成功解码了JSON请求体，HTTP响应状态始终为200，并且GraphQL请求执行中的任何错误都会显示在GraphQL响应的error部分中。默认和首选的媒体类型是 application/graphql+json，但也支持application/json。</p><p>GraphQlHttpHandler 通过声明 RouterFunction bean 来公开为 HTTP 端点。 Boot starter 会执行此操作。</p><h3 id=拦截器 data-numberify>拦截器<a class="anchor ms-1" href=#拦截器></a></h3><p>服务器传输允许在GraphQl Java引擎被调用之前和之后拦截请求。</p><p>HTTP和WebSocket 调用 零个或多个WebGraphQlinterceptor的链条，然后是executionGraphQlService，其调用GraphQl Java引擎。 WebGraphQLinterceptor允许应用程序拦截传入请求并执行以下操作之一：</p><ul><li>检查HTTP请求信息</li><li>自定义graphql.ExecutionInput</li><li>添加HTTP响应信息</li><li>自定义graphql.ExecutionResult</li></ul><p>例如，拦截器可以将HTTP请求标头传递到DataFetcher：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>HeaderInterceptor</span> <span class=kd>implements</span> <span class=n>WebGraphQlInterceptor</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Mono</span><span class=o>&lt;</span><span class=n>WebGraphQlResponse</span><span class=o>&gt;</span> <span class=nf>intercept</span><span class=o>(</span><span class=n>WebGraphQlRequest</span> <span class=n>request</span><span class=o>,</span> <span class=n>Chain</span> <span class=n>chain</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=na>getHeaders</span><span class=o>().</span><span class=na>getFirst</span><span class=o>(</span><span class=s>&#34;myHeader&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>request</span><span class=o>.</span><span class=na>configureExecutionInput</span><span class=o>((</span><span class=n>executionInput</span><span class=o>,</span> <span class=n>builder</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>builder</span><span class=o>.</span><span class=na>graphQLContext</span><span class=o>(</span><span class=n>Collections</span><span class=o>.</span><span class=na>singletonMap</span><span class=o>(</span><span class=s>&#34;myHeader&#34;</span><span class=o>,</span> <span class=n>value</span><span class=o>)).</span><span class=na>build</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>chain</span><span class=o>.</span><span class=na>next</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyController</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@QueryMapping</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=nf>person</span><span class=o>(</span><span class=nd>@ContextValue</span> <span class=n>String</span> <span class=n>myHeader</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>同样的，拦截器可以访问控制器添加到GraphQlContext的值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyController</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@QueryMapping</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=nf>person</span><span class=o>(</span><span class=n>GraphQLContext</span> <span class=n>context</span><span class=o>)</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>        <span class=n>context</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;cookieName&#34;</span><span class=o>,</span> <span class=s>&#34;123&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Subsequent access from a WebGraphQlInterceptor
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>HeaderInterceptor</span> <span class=kd>implements</span> <span class=n>WebGraphQlInterceptor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Mono</span><span class=o>&lt;</span><span class=n>WebGraphQlResponse</span><span class=o>&gt;</span> <span class=nf>intercept</span><span class=o>(</span><span class=n>WebGraphQlRequest</span> <span class=n>request</span><span class=o>,</span> <span class=n>Chain</span> <span class=n>chain</span><span class=o>)</span> <span class=o>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>chain</span><span class=o>.</span><span class=na>next</span><span class=o>(</span><span class=n>request</span><span class=o>).</span><span class=na>doOnNext</span><span class=o>(</span><span class=n>response</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=n>response</span><span class=o>.</span><span class=na>getExecutionInput</span><span class=o>().</span><span class=na>getGraphQLContext</span><span class=o>().</span><span class=na>get</span><span class=o>(</span><span class=s>&#34;cookieName&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>ResponseCookie</span> <span class=n>cookie</span> <span class=o>=</span> <span class=n>ResponseCookie</span><span class=o>.</span><span class=na>from</span><span class=o>(</span><span class=s>&#34;cookieName&#34;</span><span class=o>,</span> <span class=n>value</span><span class=o>).</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>response</span><span class=o>.</span><span class=na>getResponseHeaders</span><span class=o>().</span><span class=na>add</span><span class=o>(</span><span class=n>HttpHeaders</span><span class=o>.</span><span class=na>SET_COOKIE</span><span class=o>,</span> <span class=n>cookie</span><span class=o>.</span><span class=na>toString</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>WebGraphQlHandler 可以修改 ExecutionResult，例如，检查和修改在执行开始之前引发且无法使用 DataFetcherExceptionResolver 处理的请求验证错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span> <span class=kd>class</span> <span class=nc>RequestErrorInterceptor</span> <span class=kd>implements</span> <span class=n>WebGraphQlInterceptor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Mono</span><span class=o>&lt;</span><span class=n>WebGraphQlResponse</span><span class=o>&gt;</span> <span class=nf>intercept</span><span class=o>(</span><span class=n>WebGraphQlRequest</span> <span class=n>request</span><span class=o>,</span> <span class=n>Chain</span> <span class=n>chain</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>chain</span><span class=o>.</span><span class=na>next</span><span class=o>(</span><span class=n>request</span><span class=o>).</span><span class=na>map</span><span class=o>(</span><span class=n>response</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>response</span><span class=o>.</span><span class=na>isValid</span><span class=o>())</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>response</span><span class=o>;</span> 
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>List</span><span class=o>&lt;</span><span class=n>GraphQLError</span><span class=o>&gt;</span> <span class=n>errors</span> <span class=o>=</span> <span class=n>response</span><span class=o>.</span><span class=na>getErrors</span><span class=o>().</span><span class=na>stream</span><span class=o>()</span> 
</span></span><span class=line><span class=cl>                    <span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>error</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>GraphqlErrorBuilder</span><span class=o>&lt;?&gt;</span> <span class=n>builder</span> <span class=o>=</span> <span class=n>GraphqlErrorBuilder</span><span class=o>.</span><span class=na>newError</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>return</span> <span class=n>builder</span><span class=o>.</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=o>})</span>
</span></span><span class=line><span class=cl>                    <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>response</span><span class=o>.</span><span class=na>transform</span><span class=o>(</span><span class=n>builder</span> <span class=o>-&gt;</span> <span class=n>builder</span><span class=o>.</span><span class=na>errors</span><span class=o>(</span><span class=n>errors</span><span class=o>).</span><span class=na>build</span><span class=o>());</span> 
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>使用WebGraphQlHandler配置WebGraphQlinterceptor链。 这是由启动器支持的，请参见Web端点。</p><h1 id=请求执行过程 data-numberify>请求执行过程<a class="anchor ms-1" href=#请求执行过程></a></h1><p>ExecutionGraphQlService是spring调用GraphQl Java执行请求的主要抽象。主要实现是DefaultExecutionGraphQlService，配置了GraphQlSource，以访问graphql.graphql实例进行调用。</p><h2 id=graphqlsource data-numberify>GraphQLSource<a class="anchor ms-1" href=#graphqlsource></a></h2><p>GraphQlSource 是一个核心 Spring 抽象，用于访问 graphql.GraphQL 实例以用于请求执行。 它提供了一个构建器 API 来初始化 GraphQL Java 并构建一个 GraphQlSource。</p><p>调用GraphQlSource.schemaResourceBuilder()创建默认的GraphQlSource 构建器，支持 Reactive DataFetcher, Context Propagation, 和 Exception Resolution.</p><p>Spring Boot启动器通过默认的GraphQlSource.builder初始化GraphQlSource实例，还可以启用以下内容：</p><ul><li>从指定的位置加载schema文件</li><li>暴露适用于GraphQlSource.builder的属性。</li><li>探测 <a href=https://docs.spring.io/spring-graphql/docs/current/reference/html/#execution-graphqlsource-runtimewiring-configurer target=_blank rel="noopener noreferrer">RuntimeWiringConfigurer<i class="fas fa-external-link-square-alt ms-1"></i></a> bean</li><li>探测 <a href=https://www.graphql-java.com/documentation/instrumentation target=_blank rel="noopener noreferrer">Instrumentation<i class="fas fa-external-link-square-alt ms-1"></i></a> bean ，用于 <a href=https://docs.spring.io/spring-boot/docs/2.7.0-SNAPSHOT/reference/html/actuator.html#actuator.metrics.supported.spring-graphql target=_blank rel="noopener noreferrer">GraphQL metrics<i class="fas fa-external-link-square-alt ms-1"></i></a>.</li><li>探测 DataFetcherExceptionResolver bean</li><li>探测 SubscriptionExceptionResolver bean</li></ul><p>对于进一步的自定义，您可以声明自己的 GraphQlSourceBuilderCustomizer bean； 例如，用于配置您自己的 ExecutionIdProvider：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=o>(</span><span class=n>proxyBeanMethods</span> <span class=o>=</span> <span class=kc>false</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>GraphQlConfig</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Bean</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>GraphQlSourceBuilderCustomizer</span> <span class=nf>sourceBuilderCustomizer</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>(</span><span class=n>builder</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                <span class=n>builder</span><span class=o>.</span><span class=na>configureGraphQl</span><span class=o>(</span><span class=n>graphQlBuilder</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>                        <span class=n>graphQlBuilder</span><span class=o>.</span><span class=na>executionIdProvider</span><span class=o>(</span><span class=k>new</span> <span class=n>CustomExecutionIdProvider</span><span class=o>()));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=schema-资源加载 data-numberify>schema 资源加载<a class="anchor ms-1" href=#schema-资源加载></a></h3><p>GraphQlSource.Builder 可以配置一个或多个 Resource 实例被解析，然后合并在一起。 这意味着可以从任何位置加载chema文件。</p><p>默认情况下，Spring Boot 启动器在位置 classpath:graphql/**（通常为 src/main/resources/graphql）下查找扩展名为“.graphqls”或“.gqls”的模式文件。 您还可以使用文件系统位置或 Spring 资源层次结构支持的任何位置，包括从远程位置、存储或内存加载模式文件的自定义实现。</p><p>使用 classpath*:graphql/**/ 跨多个类路径位置查找模式文件，例如 跨多个模块。</p><h3 id=chema-创建 data-numberify>chema 创建<a class="anchor ms-1" href=#chema-创建></a></h3><p>默认情况下，GraphQlSource.builder使用GraphQl Java 的 GraphQLSchemaGenerato 创建graphql.schema.GraphQLSchema。 这适用于大多数应用程序，但是，如有必要，您可以通过构建器模式创建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>GraphQlSource</span><span class=o>.</span><span class=na>Builder</span> <span class=n>builder</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>builder</span><span class=o>.</span><span class=na>schemaResources</span><span class=o>(..)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>configureRuntimeWiring</span><span class=o>(..)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>schemaFactory</span><span class=o>((</span><span class=n>typeDefinitionRegistry</span><span class=o>,</span> <span class=n>runtimeWiring</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// create GraphQLSchema
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>})</span>
</span></span></code></pre></div><h3 id=runtimewiringconfigurer data-numberify>RuntimeWiringConfigurer<a class="anchor ms-1" href=#runtimewiringconfigurer></a></h3><p>你可以使用RuntimeWiringConfigurer 注册：</p><ul><li>自定义标量类型</li><li>指令处理代码</li><li>TypeResolver ，如果你想覆盖默认的TypeResolver</li><li>字段的DataFetcher，大多数程序会配置AnnotatedControllerConfigurer， 其将注解的方法配置成 DataFetcher . Spring Boot启动器默认情况下添加了AnnotatedControllerConfigurer</li></ul><p>与 Web 框架不同，GraphQL 不使用 Jackson 注释来驱动 JSON 序列化/反序列化。 自定义数据类型及其序列化必须描述为标量。</p><p>Spring Boot启动器检测到类型为RuntimeWiringConfigurer的bean ，并将其注册在GraphQlSource.builder中。 这意味着在大多数情况下，您将在配置中具有以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>GraphQlConfig</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Bean</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>RuntimeWiringConfigurer</span> <span class=nf>runtimeWiringConfigurer</span><span class=o>(</span><span class=n>BookRepository</span> <span class=n>repository</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>GraphQLScalarType</span> <span class=n>scalarType</span> <span class=o>=</span> <span class=o>...</span> <span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>SchemaDirectiveWiring</span> <span class=n>directiveWiring</span> <span class=o>=</span> <span class=o>...</span> <span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>DataFetcher</span> <span class=n>dataFetcher</span> <span class=o>=</span> <span class=n>QuerydslDataFetcher</span><span class=o>.</span><span class=na>builder</span><span class=o>(</span><span class=n>repository</span><span class=o>).</span><span class=na>single</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>wiringBuilder</span> <span class=o>-&gt;</span> <span class=n>wiringBuilder</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>scalar</span><span class=o>(</span><span class=n>scalarType</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>directiveWiring</span><span class=o>(</span><span class=n>directiveWiring</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=o>.</span><span class=na>type</span><span class=o>(</span><span class=s>&#34;Query&#34;</span><span class=o>,</span> <span class=n>builder</span> <span class=o>-&gt;</span> <span class=n>builder</span><span class=o>.</span><span class=na>dataFetcher</span><span class=o>(</span><span class=s>&#34;book&#34;</span><span class=o>,</span> <span class=n>dataFetcher</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=默认的typeresolver data-numberify>默认的TypeResolver<a class="anchor ms-1" href=#默认的typeresolver></a></h3><p>GraphQlSource.Builder 使用 ClassNameTypeResolver 作为默认的 TypeResolver ， 用于尚未通过RuntimeWiringConfigurer注册的GraphQL接口和联合。GraphQL Java中TypeResolver的目的是为从DataFetcher返回的GraphQL接口或Union字段的值确定GraphQL对象类型。</p><p>ClassNameTypeResolver尝试将值的简单类名与GraphQL对象类型匹配，如果不成功，它还会导航其超级类型，包括基类和接口，以查找匹配项。ClassNameTypeResolver提供了一个选项，用于配置名称提取函数以及Class-to-GraphQL对象类型名称映射，这将有助于覆盖更多的角点情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>GraphQlSource</span><span class=o>.</span><span class=na>Builder</span> <span class=n>builder</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>ClassNameTypeResolver</span> <span class=n>classNameTypeResolver</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ClassNameTypeResolver</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>classNameTypeResolver</span><span class=o>.</span><span class=na>setClassNameExtractor</span><span class=o>((</span><span class=n>klass</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Implement Custom ClassName Extractor here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>});</span>
</span></span><span class=line><span class=cl><span class=n>builder</span><span class=o>.</span><span class=na>defaultTypeResolver</span><span class=o>(</span><span class=n>classNameTypeResolver</span><span class=o>);</span>
</span></span></code></pre></div><h3 id=缓存 data-numberify>缓存<a class="anchor ms-1" href=#缓存></a></h3><p>GraphQLJava必须在执行操作之前解析并验证该操作。这可能会显著影响性能。为了避免重新解析和验证的需要，应用程序可以配置一个缓存和重用Document实例的PreparsedDocumentProvider。GraphQL Java文档通过PreparsedDocumentProvider提供了有关查询缓存的更多详细信息。</p><p>在Spring GraphQL中，您可以通过 GraphQlSource.Builder#configureGraphQl 注册PreparsedDocumentProvider:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Typically, accessed through Spring Boot&#39;s GraphQlSourceBuilderCustomizer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>GraphQlSource</span><span class=o>.</span><span class=na>Builder</span> <span class=n>builder</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Create provider
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PreparsedDocumentProvider</span> <span class=n>provider</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>builder</span><span class=o>.</span><span class=na>schemaResources</span><span class=o>(..)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>configureRuntimeWiring</span><span class=o>(..)</span>
</span></span><span class=line><span class=cl>        <span class=o>.</span><span class=na>configureGraphQl</span><span class=o>(</span><span class=n>graphQLBuilder</span> <span class=o>-&gt;</span> <span class=n>graphQLBuilder</span><span class=o>.</span><span class=na>preparsedDocumentProvider</span><span class=o>(</span><span class=n>provider</span><span class=o>))</span>
</span></span></code></pre></div><h3 id=指令 data-numberify>指令<a class="anchor ms-1" href=#指令></a></h3><p>GraphQL Java提供SchemaDirectiveWiring契约，帮助应用程序检测和处理指令。您可以通过RuntimeWiringConfigurer注册SchemaDirectiveWiring：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>GraphQlConfig</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     <span class=nd>@Bean</span>
</span></span><span class=line><span class=cl>     <span class=kd>public</span> <span class=n>RuntimeWiringConfigurer</span> <span class=nf>runtimeWiringConfigurer</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=k>return</span> <span class=n>builder</span> <span class=o>-&gt;</span> <span class=n>builder</span><span class=o>.</span><span class=na>directiveWiring</span><span class=o>(</span><span class=k>new</span> <span class=n>MySchemaDirectiveWiring</span><span class=o>());</span>
</span></span><span class=line><span class=cl>     <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=上下文传播 data-numberify>上下文传播<a class="anchor ms-1" href=#上下文传播></a></h2><p>Spring for GraphQL支持将上下文从服务器传输透明地传播到DataFetcher及其调用的其他组件。这包括来自Spring MVC请求处理线程的ThreadLocal上下文和来自WebFlux处理管道的Reactor上下文。</p><h3 id=webmvc data-numberify>WebMvc<a class="anchor ms-1" href=#webmvc></a></h3><p>由GraphQL Java调用的DataFetcher和其他组件可能不总是在与Spring MVC处理程序相同的线程上执行，例如，如果异步WebGraphQlInterceptor或DataFetchers切换到不同的线程。</p><p>Spring for GraphQL支持将ThreadLocal值从Servlet容器线程传播到DataFetcher和GraphQL Java调用的其他组件在其上执行的线程。为此，应用程序需要创建ThreadLocalAccessor以提取感兴趣的ThreadLocal值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>RequestAttributesAccessor</span> <span class=kd>implements</span> <span class=n>ThreadLocalAccessor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>String</span> <span class=n>KEY</span> <span class=o>=</span> <span class=n>RequestAttributesAccessor</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>extractValues</span><span class=o>(</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Object</span><span class=o>&gt;</span> <span class=n>container</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>container</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>KEY</span><span class=o>,</span> <span class=n>RequestContextHolder</span><span class=o>.</span><span class=na>getRequestAttributes</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>restoreValues</span><span class=o>(</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Object</span><span class=o>&gt;</span> <span class=n>values</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>values</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>KEY</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>RequestContextHolder</span><span class=o>.</span><span class=na>setRequestAttributes</span><span class=o>((</span><span class=n>RequestAttributes</span><span class=o>)</span> <span class=n>values</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>KEY</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>resetValues</span><span class=o>(</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Object</span><span class=o>&gt;</span> <span class=n>values</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RequestContextHolder</span><span class=o>.</span><span class=na>resetRequestAttributes</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>ThreadLocalAccessor可以在WebGraphHandler builder中注册。Boot starter检测这种类型的bean，并自动为Spring MVC应用程序注册它们，请参阅Web端点部分。</p><h2 id=异常解析 data-numberify>异常解析<a class="anchor ms-1" href=#异常解析></a></h2><p>GraphQL Java应用程序可以注册DataFetcherExceptionHandler，以决定如何在GraphQL响应的“error”部分中表示数据层的异常。</p><p>Spring for GraphQL有一个内置的DataFetcherExceptionHandler，它被配置为供默认GraphQLSource builder使用。它允许应用程序注册一个或多个按顺序调用的SpringDataFetcherExceptionResolver组件，直到将异常解析为graphql.GraphQLError对象（可能为空）列表。</p><p>DataFetcherExceptionResolver是一个异步协定。对于大多数实现，扩展DataFetcherExceptionResolverAdapter并重写其同步解析异常的resolveToSingleError或resolveToMultipleErrors方法之一就足够了。</p><p>可以通过graphql.ErrorClassification将GraphQLError分配给类别。在Spring GraphQL中，您还可以通过ErrorType进行分配，ErrorType具有以下常见分类，应用程序可以使用这些分类对错误进行分类：</p><ul><li>BAD_REQUEST</li><li>UNAUTHORIZED</li><li>FORBIDDEN</li><li>NOT_FOUND</li><li>INTERNAL_ERROR</li></ul><p>如果异常仍未解决，则默认情况下，它被分类为INTERNAL_ERROR，并带有一条包含类别名称和DataFetchingEnvironment中的executionId的通用消息。该消息故意不透明，以避免泄漏实现细节。应用程序可以使用DataFetcherExceptionResolver自定义错误详细信息。</p><p>未解决的异常与executionId一起记录在ERROR级别，以与发送到客户端的错误相关。在DEBUG级别记录已解决的异常。</p><h3 id=请求异常 data-numberify>请求异常<a class="anchor ms-1" href=#请求异常></a></h3><p>GraphQL Java引擎在解析请求时可能会遇到验证或其他错误，从而阻止请求执行。在这种情况下，响应包含一个带有null的“data”键和一个或多个全局请求级“errors”，即没有字段路径。</p><p>DataFetcherExceptionResolver无法处理此类全局错误，因为它们是在执行开始之前和调用任何DataFetcher之前引发的。应用程序可以使用传输级拦截器来检查和转换ExecutionResult中的错误。请参见WebGraphQlInterceptor下的示例。</p><h3 id=订阅异常 data-numberify>订阅异常<a class="anchor ms-1" href=#订阅异常></a></h3><p>订阅请求的发布服务器可能会以错误信号完成，在这种情况下，底层传输（例如WebSocket）会发送带有GraphQL错误列表的最终“错误”类型消息。</p><p>DataFetcherExceptionResolver无法解决订阅发布服务器的错误，因为数据DataFetcher最初只创建发布服务器。之后，传输订阅发布服务器，然后发布服务器可能会出错。</p><p>应用程序可以注册SubscriptionExceptionResolver，以解决订阅发布服务器的异常，从而将这些异常解析为要发送给客户端的GraphQL错误。</p><h2 id=批量加载 data-numberify>批量加载<a class="anchor ms-1" href=#批量加载></a></h2><p>给定一本书及其作者，我们可以为一本书创建一个DataFetcher，为其作者创建另一个DataFetcher。这允许选择有作者或没有作者的书籍，但这意味着书籍和作者不会一起加载，这在查询多本书时尤其低效，因为每本书的作者都是单独加载的。这就是所谓的N+1选择问题。</p><h3 id=dataloader-1 data-numberify>DataLoader<a class="anchor ms-1" href=#dataloader-1></a></h3><p>GraphQLJava提供了一种用于批量加载相关实体的DataLoader机制。您可以在GraphQL Java文档中找到完整的详细信息。以下是其工作原理的总结：</p><ol><li>在DataLoaderRegistry中注册DataLoader，它可以在给定唯一键的情况下加载实体。</li><li>DataFetcher可以访问DataLoader，并使用它们按id加载实体。</li><li>DataLoader通过返回future来延迟加载，以便可以在批处理中完成。</li><li>DataLoader维护加载实体的每个请求缓存，可以进一步提高效率。</li></ol><h3 id=batchloaderregistry data-numberify>BatchLoaderRegistry<a class="anchor ms-1" href=#batchloaderregistry></a></h3><p>GraphQL Java中的完整批处理加载机制需要实现多个BatchLoader接口中的一个，然后用DataLoaderRegistry中的名称将这些接口包装并注册为DataLoader。</p><p>Spring GraphQL中的API略有不同。对于注册，只有一个中央BatchLoaderRegistry公开工厂方法和一个生成器来创建和注册任意数量的批加载函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MyConfig</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>MyConfig</span><span class=o>(</span><span class=n>BatchLoaderRegistry</span> <span class=n>registry</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>registry</span><span class=o>.</span><span class=na>forTypePair</span><span class=o>(</span><span class=n>Long</span><span class=o>.</span><span class=na>class</span><span class=o>,</span> <span class=n>Author</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>registerMappedBatchLoader</span><span class=o>((</span><span class=n>authorIds</span><span class=o>,</span> <span class=n>env</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// return Mono&lt;Map&lt;Long, Author&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// more registrations ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Spring Boot starter声明了一个BatchLoaderRegistrybean，您可以将其注入到您的配置中，如上所示，或者注入到任何组件中，如控制器，以便注册批加载函数。然后，BatchLoaderRegistry被注入DefaultExecutionGraphQlService，在那里它确保每个请求的DataLoader注册。</p><p>默认情况下，DataLoader名称基于目标实体的类名。这允许@SchemaMapping方法使用泛型类型声明DataLoader参数，而无需指定名称。但是，如果需要，可以通过BatchLoaderRegistry生成器以及其他DataLoader选项自定义名称。</p><p>在许多情况下，当加载相关实体时，您可以使用@BatchMapping控制器方法，这是一种快捷方式，可以替代直接使用BatchLoaderRegistry和DataLoader的需要。BatchLoaderRegistry还提供了其他重要的好处。它支持从批处理加载函数和@BatchMapping方法访问相同的GraphQLContext，并确保上下文传播到它们。这就是为什么应用程序需要使用它。可以直接执行自己的DataLoader注册，但这样的注册将放弃上述好处。</p><h3 id=测试批量加载 data-numberify>测试批量加载<a class="anchor ms-1" href=#测试批量加载></a></h3><p>首先让BatchLoaderRegistry在DataLoaderRegistry上执行注册：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>BatchLoaderRegistry</span> <span class=n>batchLoaderRegistry</span> <span class=o>=</span> <span class=k>new</span> <span class=n>DefaultBatchLoaderRegistry</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// perform registrations...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>DataLoaderRegistry</span> <span class=n>dataLoaderRegistry</span> <span class=o>=</span> <span class=n>DataLoaderRegistry</span><span class=o>.</span><span class=na>newRegistry</span><span class=o>().</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>batchLoaderRegistry</span><span class=o>.</span><span class=na>registerDataLoaders</span><span class=o>(</span><span class=n>dataLoaderRegistry</span><span class=o>,</span> <span class=n>graphQLContext</span><span class=o>);</span>
</span></span></code></pre></div><p>现在，您可以按如下方式访问和测试各个DataLoader：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>DataLoader</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>,</span> <span class=n>Book</span><span class=o>&gt;</span> <span class=n>loader</span> <span class=o>=</span> <span class=n>dataLoaderRegistry</span><span class=o>.</span><span class=na>getDataLoader</span><span class=o>(</span><span class=n>Book</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getName</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=n>loader</span><span class=o>.</span><span class=na>load</span><span class=o>(</span><span class=mi>1L</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>loader</span><span class=o>.</span><span class=na>loadMany</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=mi>2L</span><span class=o>,</span> <span class=mi>3L</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Book</span><span class=o>&gt;</span> <span class=n>books</span> <span class=o>=</span> <span class=n>loader</span><span class=o>.</span><span class=na>dispatchAndJoin</span><span class=o>();</span> <span class=c1>// actual loading
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>assertThat</span><span class=o>(</span><span class=n>books</span><span class=o>).</span><span class=na>hasSize</span><span class=o>(</span><span class=mi>3</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>assertThat</span><span class=o>(</span><span class=n>books</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=mi>0</span><span class=o>).</span><span class=na>getName</span><span class=o>()).</span><span class=na>isEqualTo</span><span class=o>(</span><span class=s>&#34;...&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div></div></div></div><div class=card-footer><div class="post-navs d-flex justify-content-evenly"><div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-down post-prev-icon me-1" data-fa-transform=rotate-90></i>
<a href=/blog/2022/11/opentelemetry/>Opentelemetry</a></div><div class="post-nav post-next"><a href=/blog/2022/11/graphql%E8%A7%84%E8%8C%83/>Graphql规范</a>
<i class="fas fa-fw fa-chevron-down post-next-icon ms-1" data-fa-transform=rotate-270></i></div></div></div></article><section class="related-posts row card component"><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">相关文章</h2></div><div class="card-body slide px-1"><div class="slide-inner row gx-0"><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/blog/1/01/gradle-%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90/>Gradle 依赖解析</a><div class="post-meta mb-0">1年1月1日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/blog/1/01/gradle-java/>Gradle-Java</a><div class="post-meta mb-0">1年1月1日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/blog/1/01/%E7%9F%A5%E8%AF%86%E7%89%87%E6%AE%B5/>知识片段</a><div class="post-meta mb-0">1年1月1日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/blog/2022/11/opentelemetry/>Opentelemetry</a><div class="post-meta mb-0">2022年11月27日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/blog/1/01/></a><div class="post-meta mb-0">1年1月1日</div></div></div></div><button class=slide-control-left>
<i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-90></i>
<span class=visually-hidden>Left</span></button>
<button class=slide-control-right>
<i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-270></i>
<span class=visually-hidden>Right</span></button></div></section><div class="card component row post-comments" id=post-comments><div class=card-header><h2 class="card-title my-2 fs-4 text-surface">评论</h2></div><div class=card-body></div></div></div></div><aside class="col-xxl-4 sidebar d-flex"><div class="container d-flex flex-column"><div class="accordion profile"><div class="accordion-item card row text-center component"><div class="accordion-header card-header border-0" id=profile-header><a class="accordion-button d-lg-none mb-2 shadow-none p-0 bg-transparent text-surface collapsed" role=button data-bs-toggle=collapse href=#profile aria-expanded=false aria-controls=profile>Profile</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=profile aria-labelledby=profile-header><div class="col-12 d-flex align-items-center justify-content-center"><picture><img class="profile-avatar rounded-circle" alt=小胖子 src=https://banrenshan.github.io/images/profile.webp loading=lazy data-viewer-invisible width=400 height=400></picture></div><div class="col-12 profile-meta"><div class="profile-name fw-fold fs-lg">小胖子</div><div class=profile-bio>每天一点点</div></div></div></div></div><div class="accordion taxonomies-toggle"><div class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent collapsed" role=button data-bs-toggle=collapse href=#taxonomies-toggle aria-expanded=false aria-controls=taxonomies-toggle>Taxonomies</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=taxonomies-toggle><ul class="nav nav-pills nav-fill" role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=taxonomyCategoriesTab data-bs-toggle=tab data-bs-target=#taxonomyCategories type=button role=tab aria-controls=taxonomyCategories aria-selected=true>
分类</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomyTagsTab data-bs-toggle=tab data-bs-target=#taxonomyTags type=button role=tab aria-controls=taxonomyTags aria-selected=true>
标签</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomyArchivesTab data-bs-toggle=tab data-bs-target=#taxonomyArchives type=button role=tab aria-controls=taxonomyArchives aria-selected=true>
归档</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=taxonomyCategories role=tabpanel aria-labelledby=taxonomyCategoriesTab tabindex=0><a href=/categories/%E6%8A%80%E6%9C%AF/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=技术>技术
<span class="badge badge-sm text-secondary bg-white ms-1">24</span></a>
<a href=/categories/linux/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=linux>linux
<span class="badge badge-sm text-secondary bg-white ms-1">9</span></a>
<a href=/categories/java/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=java>java
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=操作系统>操作系统
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=中间件>中间件
<span class="badge badge-sm text-secondary bg-white ms-1">7</span></a>
<a href=/categories/spring/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=spring>spring
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/categories/docker/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=docker>docker
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/categories/spring-boot/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=spring-boot>spring-boot
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/categories/spring-cloud/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=spring-cloud>spring-cloud
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/categories/unbutu/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=Unbutu>Unbutu
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=https://banrenshan.github.io/categories class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=全部>全部
<span class="badge badge-sm text-secondary bg-white ms-1">13</span></a></div><div class=tab-pane id=taxonomyTags role=tabpanel aria-labelledby=taxonomyTagsTab tabindex=0><a href=/tags/java/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=java>java
<span class="badge badge-sm text-secondary bg-white ms-1">31</span></a>
<a href=/tags/linux/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=linux>linux
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=/tags/%E7%9B%91%E6%8E%A7/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=监控>监控
<span class="badge badge-sm text-secondary bg-white ms-1">4</span></a>
<a href=/tags/gradle/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=gradle>gradle
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/tags/graphql/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=graphql>graphql
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/tags/spring/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=spring>spring
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/tags/shell/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=shell>shell
<span class="badge badge-sm text-secondary bg-white ms-1">2</span></a>
<a href=/tags/docker/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=docker>docker
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/tags/filebeat/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=filebeat>filebeat
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/tags/grafana/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=grafana>grafana
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=https://banrenshan.github.io/tags class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=全部>全部
<span class="badge badge-sm text-secondary bg-white ms-1">22</span></a></div><div class=tab-pane id=taxonomyArchives role=tabpanel aria-labelledby=taxonomyArchivesTab tabindex=0><a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2022>2022 <span class="badge badge-sm text-secondary bg-white ms-1">48</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=0001>0001 <span class="badge badge-sm text-secondary bg-white ms-1">5</span></a></div></div></div></div></div><div class="accordion posts-toggle"><div class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent collapsed" role=button data-bs-toggle=collapse href=#posts-toggle aria-expanded=false aria-controls=posts-toggle>文章</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=posts-toggle><ul class="nav nav-pills nav-fill" role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=recent-posts-tab data-bs-toggle=tab data-bs-target=#recent-posts type=button role=tab aria-controls=recent-posts aria-selected=true>
最近文章</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=recent-posts role=tabpanel aria-labelledby=recent-posts-tab tabindex=0><ul class="post-list list-unstyled ms-1"><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/blog/2022/12/grafana/>Grafana</a><div class="post-meta mt-2"><span class=post-date>2022年12月10日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/blog/2022/12/gradle-basic/>Gradle-Basic</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/blog/2022/12/zero-copy/>Zero-Copy</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/blog/2022/12/java-lock/>Java-Lock</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/blog/2022/12/java-log/>Java-Log</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li></ul></div></div></div></div></div><div class="accordion post-toc d-none d-lg-block"><div class="accordion-item row mb-4 card component" id=postTOC><div class="card-header accordion-header"><h2 class="card-title fs-4 my-2 text-surface d-none d-lg-block">目录</h2><a class="accordion-button d-lg-none mb-1 collapsed shadow-none p-0 bg-transparent" role=button data-bs-toggle=collapse href=#post-toc aria-expanded=false aria-controls=post-toc>目录</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=post-toc><nav id=TableOfContents><ul><li><a href=#schemamapping>@SchemaMapping</a><ul><li><a href=#方法签名>方法签名</a></li><li><a href=#argument>@Argument</a></li><li><a href=#arguments>@Arguments</a></li><li><a href=#projectedpayload>@ProjectedPayload</a></li><li><a href=#source>Source</a></li><li><a href=#dataloader>DataLoader</a></li><li><a href=#validation>Validation</a></li></ul></li><li><a href=#batchmapping>@BatchMapping</a></li></ul><ul><li><a href=#querydsl>Querydsl</a><ul><li><a href=#构建>构建</a></li><li><a href=#自定义>自定义</a></li><li><a href=#自动注册>自动注册</a></li></ul></li><li><a href=#query-by-example>Query by Example</a></li></ul><ul><li><a href=#http>HTTP</a><ul><li><a href=#拦截器>拦截器</a></li></ul></li></ul><ul><li><a href=#graphqlsource>GraphQLSource</a><ul><li><a href=#schema-资源加载>schema 资源加载</a></li><li><a href=#chema-创建>chema 创建</a></li><li><a href=#runtimewiringconfigurer>RuntimeWiringConfigurer</a></li><li><a href=#默认的typeresolver>默认的TypeResolver</a></li><li><a href=#缓存>缓存</a></li><li><a href=#指令>指令</a></li></ul></li><li><a href=#上下文传播>上下文传播</a><ul><li><a href=#webmvc>WebMvc</a></li></ul></li><li><a href=#异常解析>异常解析</a><ul><li><a href=#请求异常>请求异常</a></li><li><a href=#订阅异常>订阅异常</a></li></ul></li><li><a href=#批量加载>批量加载</a><ul><li><a href=#dataloader-1>DataLoader</a></li><li><a href=#batchloaderregistry>BatchLoaderRegistry</a></li><li><a href=#测试批量加载>测试批量加载</a></li></ul></li></ul></nav></div></div></div></div></aside></div></main><footer class="footer mt-auto py-3 text-center container"></footer><script data-precache src=/assets/main/bundle.min.f06ce52438e0e6eee8225a013aaf3de719542ffc5ef58241be98c0f5d1df9732.js integrity="sha256-8GzlJDjg5u7oIloBOq895xlUL/xe9YJBvpjA9dHflzI=" crossorigin=anonymous async></script><script data-precache src=/assets/icons/bundle.min.4f30d5267a9f2f9d45ed93969d45ec626100a969a8b91f71f753315a261e9034.js integrity="sha256-TzDVJnqfL51F7ZOWnUXsYmEAqWmouR9x91MxWiYekDQ=" crossorigin=anonymous defer></script>
<script data-precache src=/assets/viewer/bundle.min.0a0d0099935beee41b7a7bf4543cd55e793e5f830a571b0794ef8c3602c5823c.js integrity="sha256-Cg0AmZNb7uQbenv0VDzVXnk+X4MKVxsHlO+MNgLFgjw=" crossorigin=anonymous defer></script>
<script src=/js/sw-register.js defer></script></body></html>