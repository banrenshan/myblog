<!doctype html><html class=position-relative itemscope itemtype=https://schema.org/WebPage lang=zh-hans data-bs-theme=auto data-palette=purple><head><script src=/myblog/assets/init/bundle.min.28cde6c3afc388a3d86d2a990679f9c3f5cb038fc7596a13ea18a4a0ed45c5f0.js integrity="sha256-KM3mw6/DiKPYbSqZBnn5w/XLA4/HWWoT6hikoO1FxfA=" crossorigin=anonymous></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>java-lock -</title><link rel=icon href=/myblog/favicon_hucccd9e706a19cc8586335b155a80c266_43860_16x16_resize_q75_h2_box_2.webp sizes=16x16 type=image/webp><link rel=icon href=/myblog/favicon_hucccd9e706a19cc8586335b155a80c266_43860_32x32_resize_q75_h2_box_2.webp sizes=32x32 type=image/webp><link rel=icon href=/myblog/favicon_hucccd9e706a19cc8586335b155a80c266_43860_150x150_resize_q75_h2_box_2.webp sizes=150x150 type=image/webp><link rel=apple-touch-icon href=/myblog/favicon_hucccd9e706a19cc8586335b155a80c266_43860_180x180_resize_q75_h2_box_2.webp sizes=180x180 type=image/webp><link rel=icon href=/myblog/favicon_hucccd9e706a19cc8586335b155a80c266_43860_192x192_resize_q75_h2_box_2.webp sizes=192x192 type=image/webp><link rel=mask-icon href=/myblog/safari-pinned-tab.svg color=#6f42c1><meta name=keywords content="Hugo,Bootstrap,Blog Theme"><meta name=description content="Java锁 对象头 Java对象保存在内存中时，由以下三部分组成：对象头、实例数据、对齐填充字节。
java的对象头由以下三部分组成：Mark Word、指向类的指针、数组长度（只有数组对象才有）
Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
Syschronized底层的原理 Monitor Monitor被翻译为监视器或管程
每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁(重量级)之后【之前可能要先经过轻量级锁或者偏向锁】，该对象头的Mark Word中就被设置指向Monitor对象的指针。
Monitor的结果如下：
刚开始Monitor中Owner为null
当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2, Monitor中只能有一一个Owner
在Thread-2持有锁的过程中，如果Thread-3, Thread-4， Thread-5 也来执行synchronized(obj)， 就会进入EntryList BLOCKED
Thread-2执行完同步代码块的内容，然后唤醒EntryL ist中等待的线程来竞争锁，竞争的时是非公平的
图中WaitSet中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析
注意:
synchronized必须是进入同一个对象的monitor才有上述的效果
不加synchronized的对象不会关联监视器， 不遵从以上规则
字节码层面的上理解 static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
synchronized (lock) {
​ counter++;
}
}
Code:
​	stack=2, locals=3, args_size=1
​	0: getstatic #2 // 获取静态变量
​	3: dup // 压入操作数栈顶"><meta name=twitter:card content="summary"><meta name=twitter:title content="java-lock"><meta name=twitter:description content="Java锁 对象头 Java对象保存在内存中时，由以下三部分组成：对象头、实例数据、对齐填充字节。
java的对象头由以下三部分组成：Mark Word、指向类的指针、数组长度（只有数组对象才有）
Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
Syschronized底层的原理 Monitor Monitor被翻译为监视器或管程
每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁(重量级)之后【之前可能要先经过轻量级锁或者偏向锁】，该对象头的Mark Word中就被设置指向Monitor对象的指针。
Monitor的结果如下：
刚开始Monitor中Owner为null
当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2, Monitor中只能有一一个Owner
在Thread-2持有锁的过程中，如果Thread-3, Thread-4， Thread-5 也来执行synchronized(obj)， 就会进入EntryList BLOCKED
Thread-2执行完同步代码块的内容，然后唤醒EntryL ist中等待的线程来竞争锁，竞争的时是非公平的
图中WaitSet中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析
注意:
synchronized必须是进入同一个对象的monitor才有上述的效果
不加synchronized的对象不会关联监视器， 不遵从以上规则
字节码层面的上理解 static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
synchronized (lock) {
​ counter++;
}
}
Code:
​	stack=2, locals=3, args_size=1
​	0: getstatic #2 // 获取静态变量
​	3: dup // 压入操作数栈顶"><meta property="og:title" content="java-lock"><meta property="og:description" content="Java锁 对象头 Java对象保存在内存中时，由以下三部分组成：对象头、实例数据、对齐填充字节。
java的对象头由以下三部分组成：Mark Word、指向类的指针、数组长度（只有数组对象才有）
Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
Syschronized底层的原理 Monitor Monitor被翻译为监视器或管程
每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁(重量级)之后【之前可能要先经过轻量级锁或者偏向锁】，该对象头的Mark Word中就被设置指向Monitor对象的指针。
Monitor的结果如下：
刚开始Monitor中Owner为null
当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2, Monitor中只能有一一个Owner
在Thread-2持有锁的过程中，如果Thread-3, Thread-4， Thread-5 也来执行synchronized(obj)， 就会进入EntryList BLOCKED
Thread-2执行完同步代码块的内容，然后唤醒EntryL ist中等待的线程来竞争锁，竞争的时是非公平的
图中WaitSet中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析
注意:
synchronized必须是进入同一个对象的monitor才有上述的效果
不加synchronized的对象不会关联监视器， 不遵从以上规则
字节码层面的上理解 static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
synchronized (lock) {
​ counter++;
}
}
Code:
​	stack=2, locals=3, args_size=1
​	0: getstatic #2 // 获取静态变量
​	3: dup // 压入操作数栈顶"><meta property="og:type" content="article"><meta property="og:url" content="https://banrenshan.github.io/myblog/blog/2022/12/java-lock/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-12-02T13:03:48+00:00"><meta property="article:modified_time" content="2023-10-07T19:19:27+08:00"><meta itemprop=name content="java-lock"><meta itemprop=description content="Java锁 对象头 Java对象保存在内存中时，由以下三部分组成：对象头、实例数据、对齐填充字节。
java的对象头由以下三部分组成：Mark Word、指向类的指针、数组长度（只有数组对象才有）
Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
Syschronized底层的原理 Monitor Monitor被翻译为监视器或管程
每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁(重量级)之后【之前可能要先经过轻量级锁或者偏向锁】，该对象头的Mark Word中就被设置指向Monitor对象的指针。
Monitor的结果如下：
刚开始Monitor中Owner为null
当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2, Monitor中只能有一一个Owner
在Thread-2持有锁的过程中，如果Thread-3, Thread-4， Thread-5 也来执行synchronized(obj)， 就会进入EntryList BLOCKED
Thread-2执行完同步代码块的内容，然后唤醒EntryL ist中等待的线程来竞争锁，竞争的时是非公平的
图中WaitSet中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析
注意:
synchronized必须是进入同一个对象的monitor才有上述的效果
不加synchronized的对象不会关联监视器， 不遵从以上规则
字节码层面的上理解 static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
synchronized (lock) {
​ counter++;
}
}
Code:
​	stack=2, locals=3, args_size=1
​	0: getstatic #2 // 获取静态变量
​	3: dup // 压入操作数栈顶"><meta itemprop=datePublished content="2022-12-02T13:03:48+00:00"><meta itemprop=dateModified content="2023-10-07T19:19:27+08:00"><meta itemprop=wordCount content="4396"><meta itemprop=keywords content="java,"><meta property="og:image" content="https://banrenshan.github.io/myblog/images/logo.png"><meta name=twitter:image content="https://banrenshan.github.io/myblog/images/logo.png"><meta property="og:image:alt" content="java-lock"><meta name=twitter:image:alt content="java-lock"><link rel=manifest href=/myblog/manifest.json><link data-precache rel=stylesheet href="/myblog/assets/main/bundle.min.906e48a4015f207e7ad2852421d4b8e6fda8fb5c6d1fff31855591474e60da12.css" integrity="sha256-kG5IpAFfIH560oUkIdS45v2o+1xtH/8xhVWRR05g2hI=" crossorigin=anonymous><link data-precache rel=stylesheet href=/myblog/assets/viewer/bundle.min.eb914844636cd41f221f109e99c887bbc3b6b5ffb2af7c664b284cea2d1b54b7.css integrity="sha256-65FIRGNs1B8iHxCemciHu8O2tf+yr3xmSyhM6i0bVLc=" crossorigin=anonymous></head><body><header class="mb-4 sticky-top"><nav class="top-app-bar shadow navbar navbar-expand-xxl"><div class=container><a class="navbar-brand d-flex align-items-center flex-grow-1 flex-xxl-grow-0 justify-content-xxl-start ms-2 ms-xxl-0 mx-auto me-xxl-2" href=https://banrenshan.github.io/myblog/><picture><img class=logo alt=Logo src=https://banrenshan.github.io/myblog/images/logo.webp loading=lazy width=400 height=400></picture></a><div class="offcanvas-xxl offcanvas-end flex-grow-1" data-bs-scroll=true tabindex=-1 id=navbarMenus aria-labelledby=navbarMenusLabel><div class="offcanvas-header px-4 pb-0"><div class="offcanvas-title h5" id=navbarMenusLabel></div><button type=button class="btn-close btn-close-white" data-bs-dismiss=offcanvas data-bs-target=#navbarMenus aria-label=Close></button></div><div class="offcanvas-body p-4 pt-0 p-xxl-0"><hr class=d-xxl-none><ul class="navbar-nav flex-row flex-wrap align-items-center me-auto"><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/myblog/docs/><span class="menu-icon me-1"><i class="fas fa-fw fa-book"></i></span>文档</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/myblog/series/><span class="menu-icon me-1"><i class="fas fa-fw fa-columns"></i></span>专栏</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/myblog/categories/><span class="menu-icon me-1"><i class="fas fa-fw fa-folder"></i></span>分类</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/myblog/archives/><span class="menu-icon me-1"><i class="fas fa-fw fa-file-archive"></i></span>归档</a></li><li class="nav-item col-6 col-xxl-auto"><a class="nav-link py-2 px-0 px-xxl-2" href=https://banrenshan.github.io/myblog/tags/><span class="menu-icon me-1"><i class="fas fa-fw fa-tags"></i></span>标签</a></li></ul><hr class=d-xxl-none><form class="search-bar ms-auto my-auto" action=/myblog/search/ novalidate><div class="input-group input-group-sm align-items-center"><span class="btn btn-search disabled position-absolute left-0 border-0 px-1"><i class="fas fa-fw fa-search fa-lg"></i></span>
<input class="my-1 form-control border-white rounded-5 search-input bg-body" name=q type=search placeholder=搜索 aria-label=Search required>
<span class="search-shortcut position-absolute end-0 top-0 me-2"><kbd class="bg-primary rounded shadow">/</kbd></span></div></form><hr class=d-xxl-none><ul class="navbar-nav flex-row flex-wrap align-items-center ms-md-auto"><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=fontSizeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-font"></i>
<span class=d-xxl-none>字体大小</span></a><ul class="font-size-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=fontSizeDropdown><li><button class="font-size-item dropdown-item" data-size=xs>
特小号</button></li><li><button class="font-size-item dropdown-item" data-size=sm>
小号</button></li><li><button class="font-size-item dropdown-item active" data-size=md>
中等</button></li><li><button class="font-size-item dropdown-item" data-size=lg>
大号</button></li><li><button class="font-size-item dropdown-item" data-size=xl>
特大号</button></li></ul></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=paletteDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="fas fa-fw fa-palette"></i>
<span class=d-xxl-none>配色</span></a><ul class="palette-dropdown-menu dropdown-menu dropdown-menu-end px-2 row g-2" aria-labelledby=paletteDropdown><li class="col-4 my-1"><a role=button id=palette-blue aria-label=蓝色 class="btn btn-sm w-100 palette text-bg-blue" data-palette=blue></a></li><li class="col-4 my-1"><a role=button id=palette-blue-gray aria-label=蓝灰色 class="btn btn-sm w-100 palette text-bg-blue-gray" data-palette=blue-gray></a></li><li class="col-4 my-1"><a role=button id=palette-brown aria-label=棕色 class="btn btn-sm w-100 palette text-bg-brown" data-palette=brown></a></li><li class="col-4 my-1"><a role=button id=palette-cyan aria-label=青色 class="btn btn-sm w-100 palette text-bg-cyan" data-palette=cyan></a></li><li class="col-4 my-1"><a role=button id=palette-green aria-label=绿色 class="btn btn-sm w-100 palette text-bg-green" data-palette=green></a></li><li class="col-4 my-1"><a role=button id=palette-indigo aria-label=靛青色 class="btn btn-sm w-100 palette text-bg-indigo" data-palette=indigo></a></li><li class="col-4 my-1"><a role=button id=palette-orange aria-label=橙色 class="btn btn-sm w-100 palette text-bg-orange" data-palette=orange></a></li><li class="col-4 my-1"><a role=button id=palette-pink aria-label=粉色 class="btn btn-sm w-100 palette text-bg-pink" data-palette=pink></a></li><li class="col-4 my-1"><a role=button id=palette-purple aria-label=紫色 class="btn btn-sm w-100 palette text-bg-purple" data-palette=purple></a></li><li class="col-4 my-1"><a role=button id=palette-red aria-label=红色 class="btn btn-sm w-100 palette text-bg-red" data-palette=red></a></li><li class="col-4 my-1"><a role=button id=palette-teal aria-label=蓝绿色 class="btn btn-sm w-100 palette text-bg-teal" data-palette=teal></a></li><li class="col-4 my-1"><a role=button id=palette-yellow aria-label=黄色 class="btn btn-sm w-100 palette text-bg-yellow" data-palette=yellow></a></li></ul></li><li class="nav-item dropdown col-6 col-xxl-auto"><a class="nav-link px-0 py-2 px-xxl-1" href=# id=modeDropdown role=button data-bs-toggle=dropdown aria-expanded=false><i class="mode-icon fas fa-fw fa-adjust" id=modeIcon></i>
<span class=d-xxl-none>模式</span></a><ul class="mode-dropdown-menu dropdown-menu dropdown-menu-end" aria-labelledby=modeDropdown><li class=mode-item data-color-mode=light data-icon=sun><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-sun"></i> 浅色</button></li><li class=mode-item data-color-mode=dark data-icon=moon><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-moon"></i> 深色</button></li><li class="mode-item active" data-color-mode=auto data-icon=adjust><button class=dropdown-item>
<i class="mode-icon fas fa-fw fa-adjust"></i> 自动</button></li></ul></li></ul></div></div><div class=d-flex><button class="navbar-toggler order-5 border-0" type=button data-bs-toggle=offcanvas data-bs-target=#navbarMenus aria-controls=navbarMenus aria-expanded=false aria-label="Toggle navigation">
<i class="fas fa-ellipsis-h"></i></button></div></div></nav></header><main class=container><div class="row content"><noscript><div class="alert alert-danger" role=alert>你的浏览器不支持 JavaScript。</div></noscript><div class=col-xxl-8><div class=container><nav class="row card component" aria-label=breadcrumb><div class="card-body pb-0"><ol class="hbs-breadcrumb breadcrumb flex-nowrap"><li class="breadcrumb-item text-surface"><a href=/myblog/>主页</a></li><li class="breadcrumb-item text-surface"><a href=/myblog/blog/>Blogs</a></li><li class="breadcrumb-item active">Java-Lock</li></ol></div></nav><div class="post-panel-wrapper position-relative d-flex justify-content-center"><div class="d-flex flex-row justify-content-center rounded-5 border post-panel position-fixed px-3 py-1 surface shadow-1"><a class="action action-toc d-none d-xxl-block" href=#postTOC role=button title="Table of contents"><i class="fas fa-fw fa-list-alt"></i></a>
<a class="action action-toc d-block d-xxl-none" href=#post-toc-container role=button title="Table of contents"><i class="fas fa-fw fa-list-alt"></i></a>
<a class="action action-post-comments" href=#post-comments role=button aria-label=Comments title=Comments><i class="fas fa-fw fa-comments"></i></a>
<a id=sidebarToggler class="action action-sidebar-toggler d-none d-xxl-block" role=button title="Sidebar toggler"><i class="fas fa-fw fa-expand-alt" data-fa-transform=rotate-45></i></a></div></div><article class="row card component mb-4 post"><div class=card-header><h1 class="card-title post-title my-2">Java-Lock</h1></div><div class=card-body><div class="post-meta mb-3"><span class="post-date me-1 mb-1" title="创建于 2022-12-02 13:03:48 +0000 UTC，更新于 2023-10-07 11:19:27 +0000 UTC。">2022年12月2日</span><span class="post-reading-time me-1 mb-1">21 分钟阅读</span><a href=/myblog/categories/%E6%8A%80%E6%9C%AF/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-category">
<i class="fas fa-fw fa-folder me-1"></i>技术</a><a href=/myblog/tags/java/ class="btn btn-sm btn-secondary mb-1 me-2 py-0 pe-1 post-taxonomy post-taxonomy-sm post-tag">Java</a></div><div class="mt-2 mb-3 d-block d-xxl-none"><h2 class="text-surface mb-3">目录</h2><div id=post-toc-container></div><hr class=text-secondary></div><div class="post-content mb-3" data-bs-spy=scroll data-bs-target=#TableOfContents tabindex=0><div id=post-content-body><h1 id=java锁 data-numberify>Java锁<a class="anchor ms-1" href=#java锁></a></h1><h1 id=对象头 data-numberify>对象头<a class="anchor ms-1" href=#对象头></a></h1><p>Java对象保存在内存中时，由以下三部分组成：对象头、实例数据、对齐填充字节。</p><p>java的对象头由以下三部分组成：Mark Word、指向类的指针、数组长度（只有数组对象才有）</p><p>Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/GbgLyBOmx3o2FIOTQSUJ1omMwf2bJqaQJWOIEkVNapo.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><h1 id=syschronized底层的原理 data-numberify>Syschronized底层的原理<a class="anchor ms-1" href=#syschronized底层的原理></a></h1><h2 id=monitor data-numberify>Monitor<a class="anchor ms-1" href=#monitor></a></h2><p><strong>Monitor</strong>被翻译为监视器或管程</p><p>每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁(重量级)之后【之前可能要先经过轻量级锁或者偏向锁】，该对象头的Mark Word中就被设置指向Monitor对象的指针。</p><p>Monitor的结果如下：</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/2OyH0fg-gdfN2ntPtGg3NpsMv_HHgPx-RJL7_mb--Zk.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li><p>刚开始Monitor中Owner为null</p></li><li><p>当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2, Monitor中只能有一一个Owner</p></li><li><p>在Thread-2持有锁的过程中，如果Thread-3, Thread-4， Thread-5 也来执行synchronized(obj)， 就会进入EntryList BLOCKED</p></li><li><p>Thread-2执行完同步代码块的内容，然后唤醒EntryL ist中等待的线程来竞争锁，竞争的时是非公平的</p></li><li><p>图中WaitSet中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析</p></li></ol><p>注意:</p><ul><li><p>synchronized必须是进入同一个对象的monitor才有上述的效果</p></li><li><p>不加synchronized的对象不会关联监视器， 不遵从以上规则</p></li></ul><h3 id=字节码层面的上理解 data-numberify>字节码层面的上理解<a class="anchor ms-1" href=#字节码层面的上理解></a></h3><p>static final Object lock = new Object();</p><p>static int counter = 0;</p><p>public static void main(String[] args) {</p><p>synchronized (lock) {</p><p>​ counter++;</p><p>}</p><p>}</p><p>Code:</p><p>​ stack=2, locals=3, args_size=1</p><p>​ 0: getstatic #2 // 获取静态变量</p><p>​ 3: dup // 压入操作数栈顶</p><p>​ 4: astore_1 // lock引用 存入 slot 1</p><p>​ 5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针</p><p>​ 6: getstatic #3 // 获取counter的值</p><p>​ 9: iconst_1 // 准备常数 1</p><p>​ 10: iadd // +1</p><p>​ 11: putstatic #3 // -> i</p><p>​ 14: aload_1 // &lt;- lock引用</p><p>​ 15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList</p><p>​ 16: goto 24</p><p>​ 19: astore_2 // e -> slot 2</p><p>​ 20: aload_1 // &lt;- lock引用</p><p>​ 21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList</p><p>​ 22: aload_2 // &lt;- slot 2 (e)</p><p>​ 23: athrow // throw e</p><p>​ 24: return</p><p>Exception table:</p><p>​ from to target type</p><p>​ 6 16 19 any</p><p>​ 19 22 19 any</p><p>LineNumberTable:</p><p>​ line 8: 0</p><p>​ line 9: 6</p><p>​ line 10: 14</p><p>​ line 11: 24</p><p>LocalVariableTable:</p><p>​ Start Length Slot Name Signature</p><p>​ 0 25 0 args [Ljava/lang/String;</p><p>StackMapTable: number_of_entries = 2</p><p>​ frame_type = 255 /* full_frame */</p><p>​ offset_delta = 19</p><p>​ locals = [ class &ldquo;[Ljava/lang/String;&rdquo;, class java/lang/Object ]</p><p>​ stack = [ class java/lang/Throwable ]</p><p>​ frame_type = 250 /* chop */</p><p>​ offset_delta = 4</p><p>上面讲述的都是重量级锁的状态，其实，一开始的时候并不是重量级锁的状态，而是在竞争后升级成的，下面我们来看这个升级的过程。</p><h1 id=锁升级 data-numberify>锁升级<a class="anchor ms-1" href=#锁升级></a></h1><h2 id=轻量级锁 data-numberify>轻量级锁<a class="anchor ms-1" href=#轻量级锁></a></h2><p>轻量级锁的使用<strong>场景</strong>：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><p><strong>上锁过程</strong></p><ol><li>当线程Thread0执行到monitorenter时，会在线程的栈帧中创建一个名为<strong>锁记录</strong>的结构：</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/0nteySAHqxYPbFaPMyaIhj5qLHi5Ub9uKGZ3UzjDMCo.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object【锁对象】 的 Mark Word，并将Mark Word 的值存入锁记录【解锁的时候需要替换回来】。</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/HDu2_5lSam8K4xr3kQXV0TLeY2iuK63W8ReEqC8erYE.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下：</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/K8DOty-AavAZSjKuaYrIwhPbGD5hluKAJEE6wnow5gI.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li><p>如果 cas 失败，有两种情况</p></li><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 【参考下面的章节】</p></li><li><p>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数：</p></li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/howonVgK01pPzobs376tI9NFTvcOHSZuvrjwhQtGCuU.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p><strong>解锁过程：</strong></p><ol><li><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。结束</p></li><li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p></li><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程【参考monitor】</p></li></ol><p><strong>锁膨胀过程：</strong></p><ol><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁，这时 Thread-1 加轻量级锁失败，进入锁膨胀流程。</p></li><li><p>为 Object 对象申请 Monitor 锁，让 Object markword 指向重量级锁地址,然后自己进入 Monitor 的 EntryList BLOCKED</p></li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/pSZykt9xIoqmY0751JKmBpl3X4uxBfbi-jtFLHOnGuY.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ol><h2 id=自旋锁 data-numberify>自旋锁<a class="anchor ms-1" href=#自旋锁></a></h2><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。</p><p>这是一种侥幸心里，在进入阻塞队里之前，碰碰运气一样 的重新获取锁几次，如果成功了就不必进行上下问的切换了。</p><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p><p>Java 7 之后不能控制是否开启自旋功能。</p><h2 id=偏向锁 data-numberify>偏向锁<a class="anchor ms-1" href=#偏向锁></a></h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的，就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p><p><strong>加锁过程：</strong></p><ol><li><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程。</p></li><li><p>此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p></li><li><p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象的偏向状态，这时表明在这个对象上已经存在竞争了。等待偏向线程到达安全点，进行暂停，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程</p></li><li><p>如果原来的线程依然存活，那么就会将偏向锁升级为轻量级锁，然后唤醒线程 A 执行完后续操作，线程 B 自旋获取轻量级锁。</p></li></ol><p><strong>锁撤销过程：</strong></p><ul><li><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销 。</p></li><li><p>轻量级锁会在锁记录中记录 hashCode</p></li><li><p>重量级锁会在 Monitor 中记录 hashCode</p></li></ul><p><strong>小知识：</strong></p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay=0 来禁用延迟</p></li><li><p>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</p></li></ul><h1 id=锁消除 data-numberify>锁消除<a class="anchor ms-1" href=#锁消除></a></h1><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/37SsuK_b9OaRKKLr7CVZyaL1UbdZEhZPMQmRy1pWbd4.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p>每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很快就会发现它的动态作用域被限制在concatString()方法内部。也就是说，sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p><h1 id=锁粗化 data-numberify>锁粗化<a class="anchor ms-1" href=#锁粗化></a></h1><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。上面的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p><h1 id=aqs data-numberify>AQS<a class="anchor ms-1" href=#aqs></a></h1><p>提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。</p><p>在将AQS之前，我们先讲一下锁的套路：</p><ol><li><p>当多个线程过来竞争锁的时候，只有一个【可以有多个】能成功。</p></li><li><p>获取到锁的线程会设置state为加锁状态，并设置当前线程为锁的持有者【可以支持锁重入】。【想想这是为什么】</p></li><li><p>没有获取到锁的线程，就会被协调到队列中进行排队</p></li><li><p>当锁线程释放锁之后，就会调度队列中的线程去枪锁【根据调度方式的不同，分为公平锁和非公平锁】</p></li></ol><p>在上面的流程中有几个核心点：</p><ul><li><p>state:表示锁是否被持有。每个线程枪锁时，都会判断这个锁是否被持有，没有持有则占锁</p></li><li><p>锁的持有线程信息： 当锁被持有后，还有一种情况就是持有线程又来加锁了，此时可以比对这个信息来支持重入【还需要state计数重入次数】</p></li><li><p>排队队列【阻塞队列】：这个用来用来存储等待的线程，锁释放之后，会叫醒其中的线程抢锁。</p></li></ul><p>明白这些以后，我们先看看怎么使用AQS，稍后再说源码。</p><p>下面的代码是一个不可重入的互斥锁，它使用值 0 表示解锁状态，使用值 1 表示锁定状态。 虽然不可重入锁并不严格要求记录当前所有者线程，建议这样做，因为更容易监控。 它还支持condition：</p><p>class Mutex implements Lock, java.io.Serializable {</p><p>// Our internal helper class</p><p>private static class Sync extends AbstractQueuedSynchronizer {</p><p>// 获取锁</p><p>public boolean tryAcquire(int acquires) {</p><p>​ assert acquires == 1; // Otherwise unused</p><p>​ if (compareAndSetState(0, 1)) {</p><p>​ setExclusiveOwnerThread(Thread.currentThread());</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>}</p><p>// 释放锁</p><p>protected boolean tryRelease(int releases) {</p><p>​ assert releases == 1; // Otherwise unused</p><p>​ if (!isHeldExclusively()) //判断线程是否是锁的持有者</p><p>​ throw new IllegalMonitorStateException();</p><p>​ setExclusiveOwnerThread(null);</p><p>​ setState(0);</p><p>​ return true;</p><p>}</p><p>// 检测锁是否已经被占用</p><p>public boolean isLocked() {</p><p>​ return getState() != 0;</p><p>}</p><p>// 检测当前线程是否是锁的持有者</p><p>public boolean isHeldExclusively() {</p><p>​ // a data race, but safe due to out-of-thin-air guarantees</p><p>​ return getExclusiveOwnerThread() == Thread.currentThread();</p><p>}</p><p>//创建 Condition</p><p>public Condition newCondition() {</p><p>​ return new ConditionObject();</p><p>}</p><p>// 反序列化</p><p>private void readObject(ObjectInputStream s)</p><p>​ throws IOException, ClassNotFoundException {</p><p>​ s.defaultReadObject();</p><p>​ setState(0); // reset to unlocked state</p><p>}</p><p>}</p><p>// The sync object does all the hard work. We just forward to it.</p><p>private final Sync sync = new Sync();</p><p>public void lock() { sync.acquire(1); }</p><p>public boolean tryLock() { return sync.tryAcquire(1); }</p><p>public void unlock() { sync.release(1); }</p><p>public Condition newCondition() { return sync.newCondition(); }</p><p>public boolean isLocked() { return sync.isLocked(); }</p><p>public boolean isHeldByCurrentThread() {</p><p>return sync.isHeldExclusively();</p><p>}</p><p>public boolean hasQueuedThreads() {</p><p>return sync.hasQueuedThreads();</p><p>}</p><p>public void lockInterruptibly() throws InterruptedException {</p><p>sync.acquireInterruptibly(1);</p><p>}</p><p>public boolean tryLock(long timeout, TimeUnit unit)</p><p>​ throws InterruptedException {</p><p>return sync.tryAcquireNanos(1, unit.toNanos(timeout));</p><p>}</p><p>}</p><p>看完这些代码，你可能比较晕，里面提供了一些名字几乎相同的方法，比如release和tryRelease，我们先来解析一下这个。</p><p>我们先来看几个受保护的方法，需要子类去实现的：</p><ul><li><p>tryAcquire(int arg)：获取独占锁，成功返回true，失败返回false。该方法内会根据state值来决定返回结果</p></li><li><p>tryRelease(int arg)：释放独占锁，成功返回true,失败返回false.</p></li><li><p>tryAcquireShared(int arg)：获取共享锁，成功返回true，失败返回false。</p></li><li><p>tryReleaseShared(int arg)：释放共享锁，成功返回true,失败返回false.</p></li><li><p>isHeldExclusively：是否是独占锁。</p></li></ul><p>这些方法需要子类继承并实现，才能提供服务。</p><p>下面我们来看AQS提供的对外公开方法：</p><ul><li><p>acquire(int arg)：获取独占锁，成功则返回，失败可能会阻塞</p></li><li><p>acquireInterruptibly(int arg)：acquire的升级版，获取锁的过程支持可打断</p></li><li><p>acquireShared(int arg)：获取共享锁，负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</p></li><li><p>acquireSharedInterruptibly(int arg)：获取共享锁，过程支持可打断。</p></li><li><p>release(int arg)：释放独占锁</p></li><li><p>releaseShared(int arg)：释放共享锁，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></li><li><p>tryAcquireNanos(int arg, long nanosTimeout)：获取独占锁，支持超时</p></li><li><p>tryAcquireSharedNanos(int arg, long nanosTimeout)：获取共享锁，支持超时</p></li></ul><p>这些方法提供了加锁的入口，我们应该先从这些方法的源码看起。</p><p>等待队列</p><p>​</p><p>​ // CANCELLED，值为1，表示当前的线程被取消；</p><p>​ // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</p><p>​ // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</p><p>​ // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</p><p>​ // 值为0，表示当前节点在sync队列中，等待着获取锁。</p><p>​ volatile int waitStatus; //等待的状态</p><p>​ volatile Node prev; //前一个节点</p><p>​ volatile Node next; //后一个节点</p><p>​ volatile Thread thread; //持有该节点的线程</p><p>​ Node nextWaiter; //存储condition队列中的后继节点。</p><p>​ Node() { // Used to establish initial head or SHARED marker</p><p>​ }</p><p>​ Node(Thread thread, Node mode) { // Used by addWaiter</p><p>​ this.nextWaiter = mode;</p><p>​ this.thread = thread;</p><p>​ }</p><p>​ Node(Thread thread, int waitStatus) { // Used by Condition</p><p>​ this.waitStatus = waitStatus;</p><p>​ this.thread = thread;</p><p>​ }</p><h2 id=独占加锁流程reentrantlock data-numberify>独占加锁流程【ReentrantLock】<a class="anchor ms-1" href=#独占加锁流程reentrantlock></a></h2><p>代码顺序：lock&#187; acquire(1)&#187;tryAcquire(1)【ReentrantLock.Sync.nonfairTryAcquire(1)】&#187;addWaiter(Node.EXCLUSIVE), 1)&#187;acquireQueued</p><p>对应的流程：开始&#187;获取锁，成功则终止&#187;添加到等待队列&#187;再次尝试获取锁，失败则等待</p><p>【入口，尝试直接加锁，简化版】</p><p>​ final void lock() {</p><p>​ if (compareAndSetState(0, 1))</p><p>​ setExclusiveOwnerThread(Thread.currentThread());</p><p>​ else</p><p>​ acquire(1);</p><p>​ }</p><p>【流程概览】</p><p>public final void acquire(int arg) { //arg=1</p><p>​ if (!tryAcquire(arg) && // 尝试获取锁，成功则返回</p><p>​ acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //添加到等待队列 ，Node.EXCLUSIVE是null,表示独占模式</p><p>​ selfInterrupt(); //该模式下不支持打断，这个是被打断线程获取到锁之后，根据之前的打断状态，然后自我打断</p><p>}</p><p>【获取锁的过程，详细版】tryAcquire底层执行的是下面的代码：</p><p>​ final boolean nonfairTryAcquire(int acquires) { //acquires=1</p><p>​ final Thread current = Thread.currentThread();</p><p>​ int c = getState();</p><p>​ if (c == 0) { // 0:未加锁</p><p>​ if (compareAndSetState(0, acquires)) { //加锁</p><p>​ setExclusiveOwnerThread(current);</p><p>​ return true;</p><p>​ }</p><p>​ }</p><p>​ else if (current == getExclusiveOwnerThread()) { //是否是锁重入</p><p>​ int nextc = c + acquires;</p><p>​ if (nextc &lt; 0) // overflow //超过整数的范围了，重入的次数太多了</p><p>​ throw new Error(&ldquo;Maximum lock count exceeded&rdquo;);</p><p>​ setState(nextc); //锁重入计数</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>​ }</p><p>枪锁失败，【添加节点到阻塞队列】</p><p>private Node addWaiter(Node mode) { //mode 是null</p><p>​ Node node = new Node(Thread.currentThread(), mode); //mode传入null，代表该节点不是用于await队列</p><p>​ // Try the fast path of enq; backup to full enq on failure</p><p>​ Node pred = tail;</p><p>​ if (pred != null) { //队列中有节点</p><p>​ node.prev = pred; //设置添加节点的前驱</p><p>​ if (compareAndSetTail(pred, node)) { //设置当前节点为尾节点</p><p>​ pred.next = node; //原先尾节点的next指向新的尾节点</p><p>​ return node;</p><p>​ }</p><p>​ }</p><p>​ // 初始化队列，并添加节点</p><p>​ enq(node);</p><p>​ return node;</p><p>}</p><p>【初始化等待对立，并添加节点】</p><p>private Node enq(final Node node) {</p><p>​ for (;;) {</p><p>​ Node t = tail;</p><p>​ if (t == null) { // 这是第一次进来，初始化队列，头尾相等，</p><p>​ if (compareAndSetHead(new Node())) //设置头节点</p><p>​ tail = head; //设置尾节点</p><p>​ } else { //第二次进来，将新节点添加到队列</p><p>​ node.prev = t;</p><p>​ if (compareAndSetTail(t, node)) {</p><p>​ t.next = node;</p><p>​ return t;</p><p>​ }</p><p>​ }</p><p>​ }</p><p>}</p><p>【队列节点进入阻塞状态】</p><p>final boolean acquireQueued(final Node node, int arg) { //node表示被添加的节点 arg=1</p><p>​ boolean failed = true;</p><p>​ try {</p><p>​ boolean interrupted = false; //线程阻塞的过程中，是否被打断过</p><p>​ for (;;) { //线程被唤醒也会走这里</p><p>​ final Node p = node.predecessor(); //前驱节点</p><p>​ //如果是队列中的第一个节点，阻塞前，再尝试获取一把锁</p><p>​ if (p == head && tryAcquire(arg)) {</p><p>​ setHead(node); //将节点设置为头节点，原先头节点移除</p><p>​ p.next = null; // help GC</p><p>​ failed = false;</p><p>​ return interrupted;</p><p>​ }</p><p>​ // 检查受否应该让线程阻塞，通过设置节点的waitStatus</p><p>​ if (shouldParkAfterFailedAcquire(p, node) &&</p><p>​ parkAndCheckInterrupt()) //阻塞线程</p><p>​ interrupted = true; //线程被打断过则设置打断标记为true</p><p>​ }</p><p>​ } finally {</p><p>​ if (failed)</p><p>​ cancelAcquire(node);</p><p>​ }</p><p>}</p><p>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // node.pre == pred</p><p>​ int ws = pred.waitStatus;</p><p>​ if (ws == Node.SIGNAL) //-1 ， 节点状态已经是Signal了，可以被阻塞</p><p>​ return true;</p><p>​ if (ws > 0) { //前驱节点被取消了</p><p>​ do { //删除前驱节点</p><p>​ node.prev = pred = pred.prev;</p><p>​ } while (pred.waitStatus > 0);</p><p>​ pred.next = node;</p><p>​ } else { //0或-3(PROPAGATE)的情况</p><p>​ // 设置节点为signal</p><p>​ compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</p><p>​ }</p><p>​ return false;</p><p>}</p><p>// 阻塞线程了</p><p>private final boolean parkAndCheckInterrupt() {</p><p>​ LockSupport.park(this);</p><p>​ // 判断线程是否被打断过，并清除打断标记</p><p>​ return Thread.interrupted();</p><p>}</p><p>下面是线程A持有锁，线程B抢锁过程的示意图：</p><ol><li>Thead-0获取到了锁</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/674-z2-6WcjZhCg-QJH0KE4P5-Va6VbgzVa42UYAzGk.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>Thread-1 执行了CAS 尝试将 state 由 0 改为 1，结果失败。进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/_d7XwjkkjIFlEumUp_7WyuphGfy5HpWTon7Y3bIN79Y.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>接下来进入 addWaiter 逻辑，构造 Node 队列。图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 。Node 的创建是懒惰的 。其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/LPf4WQFzWF7FLGYbP7Ihx-4_ZKKoSzDYaEHUfpKNGKk.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>当前线程进入 acquireQueued 逻辑 【acquireQueued 会在一个死循环中尝试几次获得锁，失败后进入 park 阻塞 】。如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 。 进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false；</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/dtbDnvAWG9A6QTCjFki4GNrL8FSv8VNYg4pxM6yqiXE.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败。当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true。进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/TnquWZAIXSPsAP_Y8ThRudrSbZuwsGjUgl4U-1oyUI0.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>再次有多个线程经历上述过程竞争失败，变成这个样子：</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/xRn7Qv5aO3uFqAO1kVyPXX5IIHBYLsQAvMveRr1SAW4.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><h2 id=独占锁解锁流程 data-numberify>独占锁解锁流程<a class="anchor ms-1" href=#独占锁解锁流程></a></h2><p>【释放锁的总流程】</p><p>public final boolean release(int arg) {</p><p>​ if (tryRelease(arg)) { //解锁成功</p><p>​ Node h = head;</p><p>​ if (h != null && h.waitStatus != 0) //有排队等待的线程, -1 -2 -3</p><p>​ unparkSuccessor(h); //唤醒线程</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>}</p><p>【释放锁的操作】</p><p>​ protected final boolean tryRelease(int releases) { //releases=1</p><p>​ int c = getState() - releases;</p><p>​ if (Thread.currentThread() != getExclusiveOwnerThread()) //必须是持有锁的线程才能释放锁</p><p>​ throw new IllegalMonitorStateException();</p><p>​ boolean free = false;</p><p>​ if (c == 0) { // c=0 ；表示锁都释放成功了，其他大于0的值，表示还有重入的锁</p><p>​ free = true;</p><p>​ setExclusiveOwnerThread(null);</p><p>​ }</p><p>​ setState(c);</p><p>​ return free;</p><p>​ }</p><p>【唤醒其他线程来枪锁】</p><p>private void unparkSuccessor(Node node) { //node是头节点</p><p>​ // 如果节点是负值，代表是需要唤醒后续节点</p><p>​ int ws = node.waitStatus;</p><p>​ if (ws &lt; 0)</p><p>​ // 节点修改成0，该节点如果是线程节点，在唤醒后可能被删除了</p><p>​ compareAndSetWaitStatus(node, ws, 0);</p><p>​ // unpark后继节点，通常是下一个节点。 但如果下个节点的状态是取消或明显为空，</p><p>​ // 从尾部向后遍历以找到实际未取消的节点。</p><p>​ Node s = node.next;</p><p>​ if (s == null || s.waitStatus > 0) { // 1代表取消</p><p>​ s = null;</p><p>​ for (Node t = tail; t != null && t != node; t = t.prev)</p><p>​ if (t.waitStatus &lt;= 0)</p><p>​ s = t; // 找到待唤醒的节点</p><p>​ }</p><p>​ if (s != null) //唤醒后续节点</p><p>​ LockSupport.unpark(s.thread);</p><p>}</p><p>此时需要我们继续回到原先抢锁暂停的地方。</p><p>我们来总结一下这个过程：</p><ol><li>Thread-0 释放锁，进入 tryRelease 流程，如果成功，设置 exclusiveOwnerThread 为 null，state = 0</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/Mt1UKR4hH_Z7VQG-3bFrngkq3l9V2J5CNH60eInHmFE.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程，找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1回到 Thread-1 的 acquireQueued 流程：</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/tACwDnvGDEj7sfIRB4_5Bz6zmdHneXp7ESE8_JqH99I.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>如果加锁成功（没有竞争），会设置exclusiveOwnerThread 为 Thread-1，state = 1。如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了：</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/KpOKK2_nqucCq3_-wv4r_x9oZknBPI6OSBWFWjiTmhQ.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>如果不巧又被 Thread-4 占了先，Thread-4 被设置为 exclusiveOwnerThread，state = 1。Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ol><h2 id=打断锁的原理 data-numberify>打断锁的原理<a class="anchor ms-1" href=#打断锁的原理></a></h2><p>上面的代码中所讲的锁，是不可打断的。即使线程被打断，他仍然在队列节点中等待。当抢到锁之后，会根据线程的打断记录来进行一次自我打断的调用。</p><p>acquireInterruptibly(int arg)方法支持打断，我们来看一下原理：</p><p>public final void acquireInterruptibly(int arg)</p><p>​ throws InterruptedException {</p><p>​ if (Thread.interrupted())</p><p>​ throw new InterruptedException();</p><p>​ if (!tryAcquire(arg)) // 尝试获取锁，成功则终止</p><p>​ doAcquireInterruptibly(arg);</p><p>}</p><p>下面就是加入阻塞队列的流程了，跟上面的几乎一样：</p><p>private void doAcquireInterruptibly(int arg)</p><p>​ throws InterruptedException {</p><p>​ final Node node = addWaiter(Node.EXCLUSIVE);</p><p>​ boolean failed = true;</p><p>​ try {</p><p>​ for (;;) {</p><p>​ final Node p = node.predecessor();</p><p>​ if (p == head && tryAcquire(arg)) {</p><p>​ setHead(node);</p><p>​ p.next = null; // help GC</p><p>​ failed = false;</p><p>​ return;</p><p>​ }</p><p>​ if (shouldParkAfterFailedAcquire(p, node) &&</p><p>​ parkAndCheckInterrupt()) // 被打断了</p><p>​ throw new InterruptedException(); //直接抛出异常</p><p>​ }</p><p>​ } finally {</p><p>​ if (failed)</p><p>​ cancelAcquire(node);</p><p>​ }</p><p>}</p><h2 id=公平锁的实现 data-numberify>公平锁的实现<a class="anchor ms-1" href=#公平锁的实现></a></h2><p>新线程每次在抢锁的时候，会检查队列中是否有等待的线程，有就去排队</p><p>​ protected final boolean tryAcquire(int acquires) {</p><p>​ final Thread current = Thread.currentThread();</p><p>​ int c = getState();</p><p>​ if (c == 0) {</p><p>​ // 检查是否有排队的线程</p><p>​ if (!hasQueuedPredecessors() &&</p><p>​ compareAndSetState(0, acquires)) {</p><p>​ setExclusiveOwnerThread(current);</p><p>​ return true;</p><p>​ }</p><p>​ }</p><p>​ else if (current == getExclusiveOwnerThread()) {</p><p>​ int nextc = c + acquires;</p><p>​ if (nextc &lt; 0)</p><p>​ throw new Error(&ldquo;Maximum lock count exceeded&rdquo;);</p><p>​ setState(nextc);</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>​ }</p><p>public final boolean hasQueuedPredecessors() {</p><p>​ // The correctness of this depends on head being initialized</p><p>​ // before tail and on head.next being accurate if the current</p><p>​ // thread is first in queue.</p><p>​ Node t = tail; // Read fields in reverse initialization order</p><p>​ Node h = head;</p><p>​ Node s;</p><p>​ return h != t &&</p><p>​ ((s = h.next) == null || s.thread != Thread.currentThread());</p><p>}</p><h2 id=锁超时 data-numberify>锁超时<a class="anchor ms-1" href=#锁超时></a></h2><p>流程基本跟可打算锁一样，在实现的park的时候，增加了超时时间，这样线程可以在超时之后醒来，并终止获取锁流程。</p><p>public final boolean tryAcquireNanos(int arg, long nanosTimeout)</p><p>​ throws InterruptedException {</p><p>​ if (Thread.interrupted())</p><p>​ throw new InterruptedException();</p><p>​ return tryAcquire(arg) ||</p><p>​ doAcquireNanos(arg, nanosTimeout);</p><p>}</p><p>private boolean doAcquireNanos(int arg, long nanosTimeout)</p><p>​ throws InterruptedException {</p><p>​ if (nanosTimeout &lt;= 0L)</p><p>​ return false;</p><p>​ final long deadline = System.nanoTime() + nanosTimeout;</p><p>​ final Node node = addWaiter(Node.EXCLUSIVE);</p><p>​ boolean failed = true;</p><p>​ try {</p><p>​ for (;;) {</p><p>​ final Node p = node.predecessor();</p><p>​ if (p == head && tryAcquire(arg)) {</p><p>​ setHead(node);</p><p>​ p.next = null; // help GC</p><p>​ failed = false;</p><p>​ return true;</p><p>​ }</p><p>​ nanosTimeout = deadline - System.nanoTime();</p><p>​ if (nanosTimeout &lt;= 0L)</p><p>​ return false;</p><p>​ if (shouldParkAfterFailedAcquire(p, node) &&</p><p>​ nanosTimeout > spinForTimeoutThreshold)</p><p>​ LockSupport.parkNanos(this, nanosTimeout);</p><p>​ if (Thread.interrupted())</p><p>​ throw new InterruptedException();</p><p>​ }</p><p>​ } finally {</p><p>​ if (failed) // 超时之后要执行一些清理工作</p><p>​ cancelAcquire(node);</p><p>​ }</p><p>}</p><h2 id=条件变量的实现原理 data-numberify>条件变量的实现原理<a class="anchor ms-1" href=#条件变量的实现原理></a></h2><ol><li><p>如果当前线程被中断，则抛出 InterruptedException。</p></li><li><p>保存由 getState 返回的锁状态。</p></li><li><p>以保存的状态作为参数调用 release，如果失败则抛出 IllegalMonitorStateException。</p></li><li><p>阻塞直到发出信号或被中断。</p></li><li><p>通过以保存的状态作为参数调用特定版本的获取来重新获取。</p></li><li><p>如果在步骤 4 中被阻塞时被中断，则抛出 InterruptedException。</p></li></ol><p>​ public final void await() throws InterruptedException {</p><p>​ if (Thread.interrupted())</p><p>​ throw new InterruptedException();</p><p>​ // 添加到等待队列</p><p>​ Node node = addConditionWaiter();</p><p>​ // 释放锁</p><p>​ int savedState = fullyRelease(node);</p><p>​ int interruptMode = 0;</p><p>​ // 判断节点是否已经被移动到阻塞队列，有可能刚调用await,另外一个线程调用了signal</p><p>​ while (!isOnSyncQueue(node)) {</p><p>​ LockSupport.park(this); //进入阻塞模式</p><p>​ if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) //检测节点在等待过程是否被打断</p><p>​ break;</p><p>​ }</p><p>​ // 被唤醒之后，添加到阻塞队列</p><p>​ if (acquireQueued(node, savedState) && interruptMode != THROW_IE)</p><p>​ interruptMode = REINTERRUPT;</p><p>​ if (node.nextWaiter != null)</p><p>​ unlinkCancelledWaiters(); // 清除失效的节点</p><p>​ if (interruptMode != 0)</p><p>​ reportInterruptAfterWait(interruptMode);</p><p>​ }</p><p>​ // 检测线程是否被打断</p><p>​ private int checkInterruptWhileWaiting(Node node) {</p><p>​ return Thread.interrupted() ?</p><p>​ (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</p><p>​ 0;</p><p>​ }</p><p>​ // 根据打断模式进行相应的处理</p><p>​ private void reportInterruptAfterWait(int interruptMode)</p><p>​ throws InterruptedException {</p><p>​ if (interruptMode == THROW_IE)</p><p>​ throw new InterruptedException();</p><p>​ else if (interruptMode == REINTERRUPT)</p><p>​ selfInterrupt();</p><p>​ }</p><p>final int fullyRelease(Node node) {</p><p>​ boolean failed = true;</p><p>​ try {</p><p>​ int savedState = getState();</p><p>​ if (release(savedState)) {</p><p>​ failed = false;</p><p>​ return savedState;</p><p>​ } else {</p><p>​ throw new IllegalMonitorStateException();</p><p>​ }</p><p>​ } finally {</p><p>​ if (failed)</p><p>​ node.waitStatus = Node.CANCELLED;</p><p>​ }</p><p>}</p><p>final boolean isOnSyncQueue(Node node) {</p><p>​ if (node.waitStatus == Node.CONDITION || node.prev == null)</p><p>​ return false;</p><p>​ if (node.next != null) //如果有后继节点，肯定在同步队列</p><p>​ return true;</p><p>​ return findNodeFromTail(node);</p><p>}</p><p>// 从阻塞队列中查找该节点，true表示在阻塞队列</p><p>private boolean findNodeFromTail(Node node) {</p><p>​ Node t = tail;</p><p>​ for (;;) {</p><p>​ if (t == node)</p><p>​ return true;</p><p>​ if (t == null)</p><p>​ return false;</p><p>​ t = t.prev;</p><p>​ }</p><p>}</p><p>【添加等待节点】</p><p>​ private Node addConditionWaiter() {</p><p>​ Node t = lastWaiter;</p><p>​ // 取消失效的等待节点</p><p>​ if (t != null && t.waitStatus != Node.CONDITION) {</p><p>​ unlinkCancelledWaiters();</p><p>​ t = lastWaiter;</p><p>​ }</p><p>​ //下面的流程就是创建节点并添加到队列中</p><p>​ Node node = new Node(Thread.currentThread(), Node.CONDITION);</p><p>​ if (t == null)</p><p>​ firstWaiter = node;</p><p>​ else</p><p>​ t.nextWaiter = node;</p><p>​ lastWaiter = node;</p><p>​ return node;</p><p>​ }</p><h3 id=唤醒机制 data-numberify>唤醒机制<a class="anchor ms-1" href=#唤醒机制></a></h3><p>​ public final void signal() {</p><p>​ if (!isHeldExclusively())</p><p>​ throw new IllegalMonitorStateException();</p><p>​ Node first = firstWaiter;</p><p>​ if (first != null)</p><p>​ doSignal(first);</p><p>​ }</p><p>​ private void doSignal(Node first) {</p><p>​ do {</p><p>​ if ( (firstWaiter = first.nextWaiter) == null)</p><p>​ lastWaiter = null;</p><p>​ first.nextWaiter = null;</p><p>​ } while (!transferForSignal(first) &&</p><p>​ (first = firstWaiter) != null);</p><p>​ }</p><p>final boolean transferForSignal(Node node) {</p><p>​ // 如果设置不成功，说明切点已经被取消</p><p>​ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</p><p>​ return false;</p><p>​ // 节点入队，p是当前节点的前驱</p><p>​ Node p = enq(node);</p><p>​ int ws = p.waitStatus;</p><p>​ // 前驱节点需要设置waitstatus=-1,表示他的后继节点需要被唤醒</p><p>​ if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</p><p>​ LockSupport.unpark(node.thread);</p><p>​ return true;</p><p>}</p><p>下面我们来对这个代码流程进行总结：</p><ol><li>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程。创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部。</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/R5ME5HM2JLIUrbY-cZY7xFnQIr68Fq90GT_lt9oHTO0.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/Mm3U23PjMwPdo2S_4KxODPfAzxNAr3SyQ7auqcFJB24.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/vcJBjn8znJnIN4tPdnoR5C0OhXeVNEk65mctU2NpSZk.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>park 阻塞 Thread-0：</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/u1CjQTNu9IYKiMy3YDsrr1hU-B170F_l6amaXIIrBnY.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>下面进入唤醒流程，假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/nYSEMuThjEXWtF1TohQ94p7GHTIfX-_1EpXAnMz9EdI.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/CGIzn_1AdHAPJEQbB9BXP-MlJ5VCR9PTXQ4bQWFIKrE.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>Thread-1 释放锁，进入 unlock 流程，略。</li></ol><h2 id=读写锁 data-numberify>读写锁<a class="anchor ms-1" href=#读写锁></a></h2><p>读写锁的应用场景：【更新缓存】</p><p>class CachedData {</p><p>Object data;</p><p>volatile boolean cacheValid;</p><p>final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</p><p>void processCachedData() {</p><p>rwl.readLock().lock();</p><p>if (!cacheValid) {</p><p>​ // 获取写锁之前必须释放读锁</p><p>​ rwl.readLock().unlock();</p><p>​ rwl.writeLock().lock();</p><p>​ try {</p><p>​ // 重新检查，可能会有别的写线程已经修改了数据</p><p>​ if (!cacheValid) {</p><p>​ data = &mldr;</p><p>​ cacheValid = true;</p><p>​ }</p><p>​ // 在释放写锁前，先降级为读锁</p><p>​ rwl.readLock().lock();</p><p>​ } finally {</p><p>​ rwl.writeLock().unlock(); // 释放了写锁，但是仍然持有读锁</p><p>​ }</p><p>}</p><p>try {</p><p>​ use(data);</p><p>} finally {</p><p>​ rwl.readLock().unlock();</p><p>}</p><p>}</p><p>}</p><p>在看源代码之前，我们先来明确几点：</p><ul><li><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p></li><li><p>流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</p></li><li><p>上写锁成功之后，后序的节点也会依次加入到阻塞队列中。不过，在写锁释放的时候，会唤醒所有的读锁【假如后面紧跟者着多个读锁】</p></li></ul><p>先看一下锁的构建函数,底层使用的是同一个同步器：</p><p>public ReentrantReadWriteLock(boolean fair) {</p><p>​ sync = fair ? new FairSync() : new NonfairSync();</p><p>​ readerLock = new ReadLock(this);</p><p>​ writerLock = new WriteLock(this);</p><p>}</p><p>​ protected ReadLock(ReentrantReadWriteLock lock) {</p><p>​ sync = lock.sync;</p><p>​ }</p><p>​ protected WriteLock(ReentrantReadWriteLock lock) {</p><p>​ sync = lock.sync;</p><p>​ }</p><h3 id=写锁加锁 data-numberify>写锁加锁<a class="anchor ms-1" href=#写锁加锁></a></h3><p>// 下面这些代码是不是很熟悉，关键看子类实现的tryAcquire方法</p><p>public void lock() {</p><p>​ sync.acquire(1);</p><p>}</p><p>public final void acquire(int arg) {</p><p>​ if (!tryAcquire(arg) &&</p><p>​ acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</p><p>​ selfInterrupt();</p><p>}</p><p>【写锁加锁】:</p><ol><li><p>（如果读锁计数非零）||（写锁计数非零且不是当前线程），写锁获取失败</p></li><li><p>如果锁计数超过限定的范围，则抛出异常</p></li><li><p>否则，此线程有资格锁定， 并更新状态并设置所有者。</p></li></ol><p>​ protected final boolean tryAcquire(int acquires) {</p><p>​ Thread current = Thread.currentThread();</p><p>​ int c = getState();</p><p>​ int w = exclusiveCount(c); //获取写锁上的计数</p><p>​ if (c != 0) {</p><p>​ //写锁计数不为零，并且非当前线程，则获取锁失败</p><p>​ if (w == 0 || current != getExclusiveOwnerThread())</p><p>​ return false;</p><p>​ if (w + exclusiveCount(acquires) > MAX_COUNT)</p><p>​ throw new Error(&ldquo;Maximum lock count exceeded&rdquo;);</p><p>​ // Reentrant acquire</p><p>​ setState(c + acquires);</p><p>​ return true;</p><p>​ }</p><p>​ // writerShouldBlock：用来判断是否是公平锁，非公平默认返回true</p><p>​ if (writerShouldBlock() ||</p><p>​ //cas 更新锁计数，成功则返回true,表示加锁成功</p><p>​ !compareAndSetState(c, c + acquires))</p><p>​ return false;</p><p>​ setExclusiveOwnerThread(current);</p><p>​ return true;</p><p>​ }</p><p>假如现在写锁加锁成功了，还没有释放锁，我们来看读锁的工作流程。</p><p>public void lock() {</p><p>​ sync.acquireShared(1);</p><p>​ }</p><p>public final void acquireShared(int arg) { // arg=1</p><p>​ // -1 表示失败</p><p>​ // 0 表示成功，但后继节点不会继续唤醒</p><p>​ // 正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</p><p>​ if (tryAcquireShared(arg) &lt; 0) // 尝试获取锁，成功则返回1，失败则返回-1</p><p>​ doAcquireShared(arg); //进入阻塞队列</p><p>}</p><h3 id=共享锁获取流程 data-numberify>共享锁获取流程<a class="anchor ms-1" href=#共享锁获取流程></a></h3><ol><li><p>如果其他线程持有写锁，则失败，返回-1</p></li><li><p>cas更新读锁计数</p></li><li><p>如果失败，进入完整版本的获取锁流程，该流程可能会让线程进入等待队列</p></li></ol><p>​ protected final int tryAcquireShared(int unused) {</p><p>​ Thread current = Thread.currentThread();</p><p>​ int c = getState();</p><p>​ // 判断是否有写线程上锁，并且写线程不是当前线程</p><p>​ if (exclusiveCount(c) != 0 &&</p><p>​ getExclusiveOwnerThread() != current)</p><p>​ return -1;</p><p>​ int r = sharedCount(c);</p><p>​ if (!readerShouldBlock() &&</p><p>​ r &lt; MAX_COUNT &&</p><p>​ compareAndSetState(c, c + SHARED_UNIT)) { // cas抢锁</p><p>​ if (r == 0) {</p><p>​ firstReader = current;</p><p>​ firstReaderHoldCount = 1;</p><p>​ } else if (firstReader == current) {</p><p>​ firstReaderHoldCount++;</p><p>​ } else {</p><p>​ HoldCounter rh = cachedHoldCounter;</p><p>​ if (rh == null || rh.tid != getThreadId(current))</p><p>​ cachedHoldCounter = rh = readHolds.get();</p><p>​ else if (rh.count == 0)</p><p>​ readHolds.set(rh);</p><p>​ rh.count++;</p><p>​ }</p><p>​ return 1; // 获得了读锁</p><p>​ }</p><p>​ return fullTryAcquireShared(current); // 完成版的抢锁流程</p><p>​ }</p><p>【完整版的读锁获取流程】，比较难懂，掠过</p><p>​ final int fullTryAcquireShared(Thread current) {</p><p>​ HoldCounter rh = null;</p><p>​ for (;;) {</p><p>​ int c = getState();</p><p>​ if (exclusiveCount(c) != 0) { //判断写锁计数</p><p>​ if (getExclusiveOwnerThread() != current) //判断写锁线程是否是当前线程</p><p>​ return -1;</p><p>​ // else we hold the exclusive lock; blocking here</p><p>​ // would cause deadlock.</p><p>​ } else if (readerShouldBlock()) {</p><p>​ // Make sure we&rsquo;re not acquiring read lock reentrantly</p><p>​ if (firstReader == current) {</p><p>​ // assert firstReaderHoldCount > 0;</p><p>​ } else {</p><p>​ if (rh == null) {</p><p>​ rh = cachedHoldCounter;</p><p>​ if (rh == null || rh.tid != getThreadId(current)) {</p><p>​ rh = readHolds.get();</p><p>​ if (rh.count == 0)</p><p>​ readHolds.remove();</p><p>​ }</p><p>​ }</p><p>​ if (rh.count == 0)</p><p>​ return -1;</p><p>​ }</p><p>​ }</p><p>​ if (sharedCount(c) == MAX_COUNT)</p><p>​ throw new Error(&ldquo;Maximum lock count exceeded&rdquo;);</p><p>​ if (compareAndSetState(c, c + SHARED_UNIT)) {</p><p>​ if (sharedCount(c) == 0) {</p><p>​ firstReader = current;</p><p>​ firstReaderHoldCount = 1;</p><p>​ } else if (firstReader == current) {</p><p>​ firstReaderHoldCount++;</p><p>​ } else {</p><p>​ if (rh == null)</p><p>​ rh = cachedHoldCounter;</p><p>​ if (rh == null || rh.tid != getThreadId(current))</p><p>​ rh = readHolds.get();</p><p>​ else if (rh.count == 0)</p><p>​ readHolds.set(rh);</p><p>​ rh.count++;</p><p>​ cachedHoldCounter = rh; // cache for release</p><p>​ }</p><p>​ return 1;</p><p>​ }</p><p>​ }</p><p>​ }</p><p>【读锁等待流程】</p><p>private void doAcquireShared(int arg) {</p><p>​ // 添加等待节点到队尾，注意这里是共享节点，不是独占了</p><p>​ final Node node = addWaiter(Node.SHARED);</p><p>​ boolean failed = true;</p><p>​ try {</p><p>​ boolean interrupted = false;</p><p>​ for (;;) {</p><p>​ final Node p = node.predecessor();</p><p>​ if (p == head) { //如果当前节点的前驱是头节点，再次尝试获取锁</p><p>​ int r = tryAcquireShared(arg);</p><p>​ if (r >= 0) { //获取锁成功</p><p>​ setHeadAndPropagate(node, r); //继续唤醒后面的读锁</p><p>​ p.next = null; // help GC</p><p>​ if (interrupted)</p><p>​ selfInterrupt();</p><p>​ failed = false;</p><p>​ return;</p><p>​ }</p><p>​ }</p><p>​ // 检查线程是否需要阻塞</p><p>​ if (shouldParkAfterFailedAcquire(p, node) &&</p><p>​ parkAndCheckInterrupt()) //阻塞线程</p><p>​ interrupted = true;</p><p>​ }</p><p>​ } finally {</p><p>​ if (failed)</p><p>​ cancelAcquire(node);</p><p>​ }</p><p>}</p><p>我们接着来看，读锁唤醒的流程setHeadAndPropagate：</p><p>// node是已经唤醒的节点，propagate待唤醒的读锁个数</p><p>private void setHeadAndPropagate(Node node, int propagate) {</p><p>​ Node h = head; // Record old head for check below</p><p>​ setHead(node);</p><p>​ if (propagate > 0 || h == null || h.waitStatus &lt; 0 ||</p><p>​ (h = head) == null || h.waitStatus &lt; 0) {</p><p>​ Node s = node.next;</p><p>​ if (s == null || s.isShared()) //后续节点还是共享节点，继续唤醒</p><p>​ doReleaseShared();</p><p>​ }</p><p>}</p><p>private void doReleaseShared() {</p><p>​ for (;;) {</p><p>​ Node h = head;</p><p>​ if (h != null && h != tail) {</p><p>​ int ws = h.waitStatus;</p><p>​ if (ws == Node.SIGNAL) { // 节点需要唤醒</p><p>​ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) //设置头节点状态为0，防止乱序唤醒</p><p>​ continue; // loop to recheck cases</p><p>​ unparkSuccessor(h);</p><p>​ }</p><p>​ else if (ws == 0 &&</p><p>​ !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</p><p>​ continue; // loop on failed CAS</p><p>​ }</p><p>​ if (h == head) // loop if head changed</p><p>​ break;</p><p>​ }</p><p>}</p><h3 id=写锁的释放流程 data-numberify>写锁的释放流程<a class="anchor ms-1" href=#写锁的释放流程></a></h3><p>public final boolean release(int arg) {</p><p>​ if (tryRelease(arg)) {</p><p>​ Node h = head;</p><p>​ if (h != null && h.waitStatus != 0)</p><p>​ unparkSuccessor(h);</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>}</p><p>protected final boolean tryRelease(int releases) {</p><p>​ if (!isHeldExclusively())</p><p>​ throw new IllegalMonitorStateException();</p><p>​ int nextc = getState() - releases;</p><p>​ boolean free = exclusiveCount(nextc) == 0;</p><p>​ if (free)</p><p>​ setExclusiveOwnerThread(null);</p><p>​ setState(nextc);</p><p>​ return free;</p><p>}</p><h3 id=读锁的释放流程 data-numberify>读锁的释放流程<a class="anchor ms-1" href=#读锁的释放流程></a></h3><p>public final boolean releaseShared(int arg) {</p><p>​ if (tryReleaseShared(arg)) {</p><p>​ doReleaseShared();</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>}</p><p>​ protected final boolean tryReleaseShared(int unused) {</p><p>​ Thread current = Thread.currentThread();</p><p>​ if (firstReader == current) {</p><p>​ // assert firstReaderHoldCount > 0;</p><p>​ if (firstReaderHoldCount == 1)</p><p>​ firstReader = null;</p><p>​ else</p><p>​ firstReaderHoldCount&ndash;;</p><p>​ } else {</p><p>​ HoldCounter rh = cachedHoldCounter;</p><p>​ if (rh == null || rh.tid != getThreadId(current))</p><p>​ rh = readHolds.get();</p><p>​ int count = rh.count;</p><p>​ if (count &lt;= 1) {</p><p>​ readHolds.remove();</p><p>​ if (count &lt;= 0)</p><p>​ throw unmatchedUnlockException();</p><p>​ }</p><p>​ &ndash;rh.count;</p><p>​ }</p><p>​ for (;;) {</p><p>​ int c = getState();</p><p>​ int nextc = c - SHARED_UNIT;</p><p>​ if (compareAndSetState(c, nextc))</p><p>​ // Releasing the read lock has no effect on readers,</p><p>​ // but it may allow waiting writers to proceed if</p><p>​ // both read and write locks are now free.</p><p>​ return nextc == 0;</p><p>​ }</p><p>​ }</p><p>我们来对上面的代码进行一下总结：假设 t1 w.lock，t2 r.lock</p><ol><li>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/cxOaEsgkZXHe_m67-5ltqO2_QNsHs7ChKaWrvxe4o2U.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/ZIoRy6PX6LOyhTZlHYYBcIat-cisbPK4jIZWdW1UXjM.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/0h08FJS_BJs-p79ki1HKDifY72TVO2gAhFELDlMxYaM.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li><p>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p></li><li><p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p></li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/ER2u-5QWismu3NsS1chwhCPUe2XD3kksVSYPYFt8wak.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/IVcISPms5F_z23sv7HQEVnZwl3Vv9yAPZt8dpRcZjw0.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>t1 w.unlock这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/IeO4uDVy6UQf5bE_i-tPiHP7gzrN3f8VZxryq701qA4.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/F9PCjCLz6gZUdhHj4AaTNxVnlOkyFdLrzYYF8YBl8J4.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/YcMTbw_vciUYa-02BFXV2LaRF8QDvTepkr38V7jo8IA.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/bpAD4b0C8pzFv2qCQJHJS-6LidAPjL3B1lcfHL2smns.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/1Pp_iqnbpFxkWw6xw4a7hhMcvkU4vgJMoJ_ZryBeLfE.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/DmUixlBLbLhN8N_FSlbaaD3laQiOXpVYzoxlzygCDvs.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点。</p></li><li><p>t2 r.unlock，t3 r.unlock。t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p></li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/W6NoQRYzUDOZ5V8Uvh5pCtGOeohBILAwr3816IHub3U.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/5EdEifmIRetQ9JjA19xr8ftyuKsd_ks1MqHvOr63J8w.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><ol><li>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束</li></ol><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/6rX9FI_lclHF8zqhuHrGRj6cqbK51S47SjmwpFoxI4U.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><h1 id=semaphore原理 data-numberify>Semaphore原理<a class="anchor ms-1" href=#semaphore原理></a></h1><p>信号量，用来限制能同时访问共享资源的线程上限。</p><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一</p><p>模拟：刚开始，permits（state）为 3，这时 5 个线程来获取资源</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/Z_rqI7QLkhf187olM8D6B3UKMXJ7Ak_a-dnEMNEI8Yo.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/B-aob5MasR4iH_o8VUJK7qyfYoL7FB5Ktwz5zkvlbMw.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p>这时 Thread-4 释放了 permits，状态如下：</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/q1R0bW4SjUQKkPNSeOIDexjAU46R5nzOdsqZyiwEZME.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><p><picture><img class=img-fluid alt=img src="https://vipkshttps8.wiz.cn/editor/63531d60-bd31-11ea-aa67-1778e2b2bbbd/20aa8caa-8757-4902-b032-92d733f8b349/resources/Za6PAAZRHQAQams18dzuxJDiaIaJShzmBwiyyeKGVzc.png?token=W.hfyxpaKeZ1ALEo-GLY7TuIA8SX33YHKhnov6_ndm3LeF2E0ocVrbQuP2ZExmv08" loading=lazy></picture></p><p>我们先来看怎么使用</p><p>​ Semaphore semaphore = new Semaphore(3);</p><p>​ for (int i = 0; i &lt; 5; i++) {</p><p>​ new Thread(() -> {</p><p>​ try {</p><p>​ semaphore.acquire();</p><p>​ System.err.println(Thread.currentThread().getName() + &ldquo;执行了&rdquo;);</p><p>​ } catch (InterruptedException e) {</p><p>​ e.printStackTrace();</p><p>​ } finally {</p><p>​ semaphore.release();</p><p>​ }</p><p>​ }).start();</p><p>​ }</p><p>看源码的顺序： new &#187; acquire &#187; release</p><p>先看如何构造：利用state创建许可数。</p><p>public Semaphore(int permits) {</p><p>​ sync = new NonfairSync(permits);</p><p>}</p><p>NonfairSync(int permits) {</p><p>​ super(permits);</p><p>}</p><p>Sync(int permits) {</p><p>​ setState(permits);</p><p>}</p><p>再看如何获取许可：</p><p>public void acquire() throws InterruptedException {</p><p>​ sync.acquireSharedInterruptibly(1);</p><p>}</p><p>public final void acquireSharedInterruptibly(int arg)</p><p>​ throws InterruptedException {</p><p>​ if (Thread.interrupted())</p><p>​ throw new InterruptedException();</p><p>​ if (tryAcquireShared(arg) &lt; 0) //代表获取许可失败</p><p>​ doAcquireSharedInterruptibly(arg);</p><p>}</p><p>protected int tryAcquireShared(int acquires) {</p><p>​ return nonfairTryAcquireShared(acquires);</p><p>}</p><p>final int nonfairTryAcquireShared(int acquires) {</p><p>​ for (;;) {</p><p>​ int available = getState();</p><p>​ int remaining = available - acquires;</p><p>​ if (remaining &lt; 0 ||</p><p>​ compareAndSetState(available, remaining)) //设置成功则获取许可成功</p><p>​ return remaining;</p><p>​ }</p><p>​ }</p><p>我们再看如何释放许可：</p><p>public void release() {</p><p>​ sync.releaseShared(1);</p><p>}</p><p>public final boolean releaseShared(int arg) {</p><p>​ if (tryReleaseShared(arg)) { //释放许可成功，则走释放成功流程，唤醒其他等待线程</p><p>​ doReleaseShared();</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>}</p><p>释放的许可直接加回state就行了</p><p>​ protected final boolean tryReleaseShared(int releases) {</p><p>​ for (;;) {</p><p>​ int current = getState();</p><p>​ int next = current + releases;</p><p>​ if (next &lt; current) // overflow</p><p>​ throw new Error(&ldquo;Maximum permit count exceeded&rdquo;);</p><p>​ if (compareAndSetState(current, next))</p><p>​ return true;</p><p>​ }</p><p>​ }</p><h1 id=countdownlatch原理 data-numberify>CountDownLatch原理<a class="anchor ms-1" href=#countdownlatch原理></a></h1><p>用来进行线程同步协作，等待所有线程完成倒计时。其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一：</p><p>public static void main(String[] args) throws InterruptedException {</p><p>​ CountDownLatch latch = new CountDownLatch(3);</p><p>​ new Thread(() -> {</p><p>​ log.debug(&ldquo;begin&mldr;&rdquo;);</p><p>​ sleep(1);</p><p>​ latch.countDown();</p><p>​ log.debug(&ldquo;end&mldr;{}&rdquo;, latch.getCount());</p><p>​ }).start();</p><p>​ new Thread(() -> {</p><p>​ log.debug(&ldquo;begin&mldr;&rdquo;);</p><p>​ sleep(2);</p><p>​ latch.countDown();</p><p>​ log.debug(&ldquo;end&mldr;{}&rdquo;, latch.getCount());</p><p>​ }).start();</p><p>​ new Thread(() -> {</p><p>​ log.debug(&ldquo;begin&mldr;&rdquo;);</p><p>​ sleep(1.5);</p><p>​ latch.countDown();</p><p>​ log.debug(&ldquo;end&mldr;{}&rdquo;, latch.getCount());</p><p>​ }).start();</p><p>​ log.debug(&ldquo;waiting&mldr;&rdquo;);</p><p>​ latch.await();</p><p>​ log.debug(&ldquo;wait end&mldr;&rdquo;);</p><p>}</p><p>先从构造看起：</p><p>public CountDownLatch(int count) {</p><p>​ if (count &lt; 0) throw new IllegalArgumentException(&ldquo;count &lt; 0&rdquo;);</p><p>​ this.sync = new Sync(count);</p><p>}</p><p>Sync(int count) {</p><p>​ setState(count);</p><p>}</p><p>再看await：</p><p>public void await() throws InterruptedException {</p><p>​ sync.acquireSharedInterruptibly(1);</p><p>}</p><p>public final void acquireSharedInterruptibly(int arg)</p><p>​ throws InterruptedException {</p><p>​ if (Thread.interrupted())</p><p>​ throw new InterruptedException();</p><p>​ if (tryAcquireShared(arg) &lt; 0)</p><p>​ doAcquireSharedInterruptibly(arg);</p><p>}</p><p>protected int tryAcquireShared(int acquires) {</p><p>​ return (getState() == 0) ? 1 : -1; // 计数不为0，就进入等待队列</p><p>}</p><p>再看countDown</p><p>public void countDown() {</p><p>​ sync.releaseShared(1);</p><p>}</p><p>public final boolean releaseShared(int arg) {</p><p>​ if (tryReleaseShared(arg)) {</p><p>​ doReleaseShared(); //唤醒等待</p><p>​ return true;</p><p>​ }</p><p>​ return false;</p><p>}</p><p>protected boolean tryReleaseShared(int releases) {</p><p>​ // 递减计数； 过渡到零时就开始唤醒等待</p><p>​ for (;;) {</p><p>​ int c = getState();</p><p>​ if (c == 0)</p><p>​ return false;</p><p>​ int nextc = c-1;</p><p>​ if (compareAndSetState(c, nextc))</p><p>​ return nextc == 0;</p><p>​ }</p><p>}</p></div></div></div><div class=card-footer><div class="post-navs d-flex justify-content-evenly"><div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-down post-prev-icon me-1" data-fa-transform=rotate-90></i>
<a href=/myblog/blog/2022/12/java-log/>Java-Log</a></div><div class="post-nav post-next"><a href=/myblog/blog/2022/12/zero-copy/>Zero-Copy</a>
<i class="fas fa-fw fa-chevron-down post-next-icon ms-1" data-fa-transform=rotate-270></i></div></div></div></article><section class="related-posts row card component"><div class=card-header><h2 class="card-title fs-4 my-2 text-surface">相关文章</h2></div><div class="card-body slide px-1"><div class="slide-inner row gx-0"><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/myblog/blog/2022/12/java-log/>Java-Log</a><div class="post-meta mb-0">2022年12月2日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/myblog/blog/2022/12/flyway/>Flyway</a><div class="post-meta mb-0">2022年12月2日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/myblog/blog/2022/12/spring-boot-deploy/>Spring-Boot-Deploy</a><div class="post-meta mb-0">2022年12月2日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/myblog/blog/2022/12/spring-boot-starter-actuator/>Spring-Boot-Starter-Actuator</a><div class="post-meta mb-0">2022年12月2日</div></div></div><div class="col-12 col-md-6 col-lg-4 me-2"><div class="post-card card card-body p-0 border-0 surface"><div class="post-card-default-img card-img-top d-flex align-items-center justify-content-center bg-body-secondary mb-1">NO IMAGE</div><a class=post-title href=/myblog/blog/2022/12/spring-mvc/>Spring-Mvc</a><div class="post-meta mb-0">2022年12月2日</div></div></div></div><button class=slide-control-left>
<i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-90></i>
<span class=visually-hidden>Left</span></button>
<button class=slide-control-right>
<i class="fas fa-2x fa-chevron-circle-down" data-fa-transform=rotate-270></i>
<span class=visually-hidden>Right</span></button></div></section><div class="card component row post-comments" id=post-comments><div class=card-header><h2 class="card-title my-2 fs-4 text-surface">评论</h2></div><div class=card-body></div></div></div></div><aside class="col-xxl-4 sidebar d-flex"><div class="container d-flex flex-column"><div class="accordion profile"><div class="accordion-item card row text-center component"><div class="accordion-header card-header border-0" id=profile-header><a class="accordion-button d-lg-none mb-2 shadow-none p-0 bg-transparent text-surface collapsed" role=button data-bs-toggle=collapse href=#profile aria-expanded=false aria-controls=profile>Profile</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=profile aria-labelledby=profile-header><div class="col-12 d-flex align-items-center justify-content-center"><picture><img class="profile-avatar rounded-circle" alt=小胖子 src=https://banrenshan.github.io/myblog/images/profile.webp loading=lazy data-viewer-invisible width=400 height=400></picture></div><div class="col-12 profile-meta"><div class="profile-name fw-fold fs-lg">小胖子</div><div class=profile-bio>每天一点点</div></div></div></div></div><div class="accordion taxonomies-toggle"><div class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent collapsed" role=button data-bs-toggle=collapse href=#taxonomies-toggle aria-expanded=false aria-controls=taxonomies-toggle>Taxonomies</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=taxonomies-toggle><ul class="nav nav-pills nav-fill" role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=taxonomyCategoriesTab data-bs-toggle=tab data-bs-target=#taxonomyCategories type=button role=tab aria-controls=taxonomyCategories aria-selected=true>
分类</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomyTagsTab data-bs-toggle=tab data-bs-target=#taxonomyTags type=button role=tab aria-controls=taxonomyTags aria-selected=true>
标签</button></li><li class=nav-item role=presentation><button class=nav-link id=taxonomyArchivesTab data-bs-toggle=tab data-bs-target=#taxonomyArchives type=button role=tab aria-controls=taxonomyArchives aria-selected=true>
归档</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=taxonomyCategories role=tabpanel aria-labelledby=taxonomyCategoriesTab tabindex=0><a href=/myblog/categories/%E6%8A%80%E6%9C%AF/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=技术>技术
<span class="badge badge-sm text-secondary bg-white ms-1">24</span></a>
<a href=/myblog/categories/linux/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=linux>linux
<span class="badge badge-sm text-secondary bg-white ms-1">9</span></a>
<a href=/myblog/categories/java/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=java>java
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=/myblog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=操作系统>操作系统
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=/myblog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=中间件>中间件
<span class="badge badge-sm text-secondary bg-white ms-1">7</span></a>
<a href=/myblog/categories/spring/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=spring>spring
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/myblog/categories/docker/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=docker>docker
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/myblog/categories/spring-boot/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=spring-boot>spring-boot
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/myblog/categories/spring-cloud/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=spring-cloud>spring-cloud
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/myblog/categories/unbutu/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=Unbutu>Unbutu
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=https://banrenshan.github.io/myblog/categories class="btn btn-sm btn-secondary post-taxonomy ps-3 post-category me-2 mb-2" title=全部>全部
<span class="badge badge-sm text-secondary bg-white ms-1">13</span></a></div><div class=tab-pane id=taxonomyTags role=tabpanel aria-labelledby=taxonomyTagsTab tabindex=0><a href=/myblog/tags/java/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=java>java
<span class="badge badge-sm text-secondary bg-white ms-1">31</span></a>
<a href=/myblog/tags/linux/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=linux>linux
<span class="badge badge-sm text-secondary bg-white ms-1">8</span></a>
<a href=/myblog/tags/%E7%9B%91%E6%8E%A7/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=监控>监控
<span class="badge badge-sm text-secondary bg-white ms-1">4</span></a>
<a href=/myblog/tags/gradle/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=gradle>gradle
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/myblog/tags/graphql/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=graphql>graphql
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/myblog/tags/spring/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=spring>spring
<span class="badge badge-sm text-secondary bg-white ms-1">3</span></a>
<a href=/myblog/tags/shell/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=shell>shell
<span class="badge badge-sm text-secondary bg-white ms-1">2</span></a>
<a href=/myblog/tags/docker/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=docker>docker
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/myblog/tags/filebeat/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=filebeat>filebeat
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=/myblog/tags/grafana/ class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=grafana>grafana
<span class="badge badge-sm text-secondary bg-white ms-1">1</span></a>
<a href=https://banrenshan.github.io/myblog/tags class="btn btn-sm btn-secondary post-taxonomy ps-3 post-tag me-2 mb-2" title=全部>全部
<span class="badge badge-sm text-secondary bg-white ms-1">22</span></a></div><div class=tab-pane id=taxonomyArchives role=tabpanel aria-labelledby=taxonomyArchivesTab tabindex=0><a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=2022>2022 <span class="badge badge-sm text-secondary bg-white ms-1">48</span></a>
<a href class="btn btn-sm btn-secondary post-taxonomy ps-3 me-2 mb-2" title=0001>0001 <span class="badge badge-sm text-secondary bg-white ms-1">5</span></a></div></div></div></div></div><div class="accordion posts-toggle"><div class="row card component accordion-item"><div class="accordion-header card-header border-0"><a class="accordion-button d-lg-none mb-1 shadow-none p-0 bg-transparent collapsed" role=button data-bs-toggle=collapse href=#posts-toggle aria-expanded=false aria-controls=posts-toggle>文章</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=posts-toggle><ul class="nav nav-pills nav-fill" role=tablist><li class=nav-item role=presentation><button class="nav-link active" id=recent-posts-tab data-bs-toggle=tab data-bs-target=#recent-posts type=button role=tab aria-controls=recent-posts aria-selected=true>
最近文章</button></li></ul><div class="tab-content mt-3"><div class="tab-pane active" id=recent-posts role=tabpanel aria-labelledby=recent-posts-tab tabindex=0><ul class="post-list list-unstyled ms-1"><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/myblog/blog/2022/12/grafana/>Grafana</a><div class="post-meta mt-2"><span class=post-date>2022年12月10日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/myblog/blog/2022/12/gradle-basic/>Gradle-Basic</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/myblog/blog/2022/12/zero-copy/>Zero-Copy</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/myblog/blog/2022/12/java-lock/>Java-Lock</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li><li class=mb-2><div class=d-flex><div class="flex-grow-1 d-flex flex-column h-auto justify-content-center"><a class=post-title href=/myblog/blog/2022/12/java-log/>Java-Log</a><div class="post-meta mt-2"><span class=post-date>2022年12月2日</span></div></div></div></li></ul></div></div></div></div></div><div class="accordion post-toc d-none d-lg-block"><div class="accordion-item row mb-4 card component" id=postTOC><div class="card-header accordion-header"><h2 class="card-title fs-4 my-2 text-surface d-none d-lg-block">目录</h2><a class="accordion-button d-lg-none mb-1 collapsed shadow-none p-0 bg-transparent" role=button data-bs-toggle=collapse href=#post-toc aria-expanded=false aria-controls=post-toc>目录</a></div><div class="card-body collapse accordion-collapse accordion-body d-lg-block" id=post-toc><nav id=TableOfContents><ul><li><a href=#monitor><strong>Monitor</strong></a><ul><li><a href=#字节码层面的上理解>字节码层面的上理解</a></li></ul></li></ul><ul><li><a href=#轻量级锁>轻量级锁</a></li><li><a href=#自旋锁>自旋锁</a></li><li><a href=#偏向锁>偏向锁</a></li></ul><ul><li><a href=#独占加锁流程reentrantlock>独占加锁流程【ReentrantLock】</a></li><li><a href=#独占锁解锁流程>独占锁解锁流程</a></li><li><a href=#打断锁的原理>打断锁的原理</a></li><li><a href=#公平锁的实现>公平锁的实现</a></li><li><a href=#锁超时>锁超时</a></li><li><a href=#条件变量的实现原理>条件变量的实现原理</a><ul><li><a href=#唤醒机制>唤醒机制</a></li></ul></li><li><a href=#读写锁>读写锁</a><ul><li><a href=#写锁加锁>写锁加锁</a></li><li><a href=#共享锁获取流程>共享锁获取流程</a></li><li><a href=#写锁的释放流程>写锁的释放流程</a></li><li><a href=#读锁的释放流程>读锁的释放流程</a></li></ul></li></ul></nav></div></div></div></div></aside></div></main><footer class="footer mt-auto py-3 text-center container"></footer><script data-precache src=/myblog/assets/main/bundle.min.4976817c50e9fbebc65d5da4994ce4fe52de9ef0821503aee57a131f470d190f.js integrity="sha256-SXaBfFDp++vGXV2kmUzk/lLenvCCFQOu5XoTH0cNGQ8=" crossorigin=anonymous async></script><script data-precache src=/myblog/assets/icons/bundle.min.4f30d5267a9f2f9d45ed93969d45ec626100a969a8b91f71f753315a261e9034.js integrity="sha256-TzDVJnqfL51F7ZOWnUXsYmEAqWmouR9x91MxWiYekDQ=" crossorigin=anonymous defer></script>
<script data-precache src=/myblog/assets/viewer/bundle.min.0a0d0099935beee41b7a7bf4543cd55e793e5f830a571b0794ef8c3602c5823c.js integrity="sha256-Cg0AmZNb7uQbenv0VDzVXnk+X4MKVxsHlO+MNgLFgjw=" crossorigin=anonymous defer></script>
<script src=/myblog/js/sw-register.js defer></script></body></html>