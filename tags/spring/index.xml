<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>spring on</title><link>https://banrenshan.github.io/myblog/tags/spring/</link><description>Recent content in spring on</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright/><lastBuildDate>Fri, 02 Dec 2022 12:02:30 +0000</lastBuildDate><atom:link href="https://banrenshan.github.io/myblog/tags/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>spring容器</title><link>https://banrenshan.github.io/myblog/blog/2022/12/spring%E5%AE%B9%E5%99%A8/</link><pubDate>Fri, 02 Dec 2022 12:02:30 +0000</pubDate><guid>https://banrenshan.github.io/myblog/blog/2022/12/spring%E5%AE%B9%E5%99%A8/</guid><description>1.容器和 Bean 介绍 控制反转也叫依赖注入(DI)，这是一个过程。对象通过下面的方式，知道自己的依赖项：
构造函数参数 工厂方法创建对象时的参数 对象的setter方法参数 然后容器在创建bean时，注入这些依赖。在这个过程中，bean控制着自身的创建，通过类上的构造函数等机制搜索所需的依赖，因此称为控制反转。
org.springframework.beans 和 org.springframework.context 包是 Spring Framework 的 IoC 容器的基础。 BeanFactory 接口管理容器中的bean。 ApplicationContext 是 BeanFactory 的扩展子接口，扩展项如下：
更容易与 Spring 的 AOP 特性集成 消息资源处理（用于国际化） 事件发布 应用层特定上下文，例如用于 Web 应用程序的 WebApplicationContext。 简而言之，BeanFactory 提供了配置框架和基本功能，ApplicationContext 增加了更多企业特定的功能。
在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。 bean 是由 Spring IoC 容器实例化、组装和管理的对象。
2.容器概览 org.springframework.context.ApplicationContext接口表示Spring IoC容器，并负责实例化，配置和组装Bean。 容器通过读取配置元数据获取有关要实例化，配置和组装哪些对象的指令。 配置元数据以XML，Java批注或Java代码表示。 它使您能够表达组成应用程序的对象以及这些对象之间的丰富相互依赖关系。
Spring提供了ApplicationContext接口的几种实现。 在独立应用程序中，通常创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。 尽管XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置来声明性地启用对这些其他元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。
在大多数应用场景中，不需要显式用户代码即可实例化一个Spring IoC容器的一个或多个实例。 例如，在Web应用程序场景中，应用程序的web.xml文件中配置简单八行样板XML就足够了（请参阅Web应用程序的便捷ApplicationContext实例化）。
下图显示了Spring的工作原理的高级视图。 您的应用程序类与配置元数据结合在一起，以便在创建和初始化ApplicationContext之后，您将拥有一个完全配置且可执行的系统或应用程序。
配置元数据 如上图所示，Spring IoC容器使用一种形式的配置元数据。 此配置元数据表示您作为应用程序开发人员如何告诉Spring容器实例化，配置和组装应用程序中的对象。
传统上，配置元数据以简单直观的XML格式提供，这是本章大部分内容用来传达Spring IoC容器的关键概念和功能的内容。
有关在Spring容器中使用其他形式的元数据的信息，请参见：</description></item><item><title>Spring-cloud-openfeign</title><link>https://banrenshan.github.io/myblog/blog/2022/11/spring-cloud-openfeign/</link><pubDate>Sun, 27 Nov 2022 20:07:02 +0000</pubDate><guid>https://banrenshan.github.io/myblog/blog/2022/11/spring-cloud-openfeign/</guid><description><![CDATA[Feign是一个声明式的Web服务客户端，web调用的代码仅仅只需要声明接口和注解。
它具有可插入的注释支持，包括Feign注释和JAX-RS注释。 Feign支持可插拔编码器和解码器。 增加了对Spring MVC注释的支持，并默认使用与Spring Web相同HttpMessageConverters。 Spring Cloud集成了CircuitBreaker和Eureka，Spring Cloud LoadBalancer。 快速入门 引入依赖 implementation &#39;org.springframework.cloud:spring-cloud-starter-openfeign&#39; 注解开启 @SpringBootApplication @EnableFeignClients public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 客户端声明 @FeignClient(&#34;stores&#34;) public interface StoreClient { @RequestMapping(method = RequestMethod.GET, value = &#34;/stores&#34;) List&lt;Store&gt; getStores(); @RequestMapping(method = RequestMethod.POST, value = &#34;/stores/{storeId}&#34;, consumes = &#34;application/json&#34;) Store update(@PathVariable(&#34;storeId&#34;) Long storeId, Store store); } @FeignClient的值是服务的名称,主要用来负载均衡.当然也可以用url属性来指定具体的地址.该接口在上下文中注册的bean名称是完全限定名称,你可以使用qualifier属性来指定别名.
上面的 load-balancer 客户端将要发现“strore”服务实际的物理地址。如果您的应用程序是Eureka客户端，那么它将解析Eureka服务注册表中的服务。如果您不想使用Eureka，则只需在外部配置中配置服务器列表即可.
Spring Cloud OpenFeign 支持 Spring Cloud LoadBalancer 阻塞模式下所有可用的功能]]></description></item><item><title>graphql-spring</title><link>https://banrenshan.github.io/myblog/blog/2022/11/graphql-spring/</link><pubDate>Sun, 27 Nov 2022 19:02:13 +0000</pubDate><guid>https://banrenshan.github.io/myblog/blog/2022/11/graphql-spring/</guid><description><![CDATA[注解驱动 Spring for GraphQL提供了一个基于注释的编程模型，其中@Controller组件使用注释来声明具有灵活方法签名的处理程序方法，以获取特定GraphQL字段的数据。例如：
@Controller public class GreetingController { @QueryMapping public String hello() { return &#34;Hello, world!&#34;; } } 将此方法绑定到查询，即查询类型下的字段。 如果未在注释上声明，则根据方法名确定查询。 Spring使用RuntimeWiring.Builder将上述处理程序方法注册为名为“hello”的查询graphql.schema.DataFetcher。
AnnotatedControllerConfigurer 检测 @Controller bean 并通过 RuntimeWiring.Builder 将标注的方法注册为 DataFetchers。 它是 RuntimeWiringConfigurer 的一个实现，可以添加到 GraphQlSource.Builder。 Spring Boot 自动将 AnnotatedControllerConfigurer 声明为 bean，并将所有 RuntimeWiringConfigurer bean 添加到 GraphQlSource.Builder 并启用对带注释的 DataFetchers 的支持。
@SchemaMapping @SchemaMapping 注解将方法映射到 GraphQL schema中的字段，并将其声明为该字段的 DataFetcher。 注解可以指定类型名称，以及字段名称：
@Controller public class BookController { @SchemaMapping(typeName=&#34;Book&#34;, field=&#34;author&#34;) public Author getAuthor(Book book) { // ... } } @SchemaMapping 注解也可以省略这些属性，在这种情况下，字段名称默认为方法名称，而类型名称默认为方法参数的简单类名称。 例如，下面默认键入Book和字段author：]]></description></item></channel></rss>