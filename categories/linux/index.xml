<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>linux on</title><link>https://banrenshan.github.io/categories/linux/</link><description>Recent content in linux on</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright/><lastBuildDate>Thu, 01 Dec 2022 11:21:20 +0000</lastBuildDate><atom:link href="https://banrenshan.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>linux 系统信息</title><link>https://banrenshan.github.io/blog/2022/12/linux-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</link><pubDate>Thu, 01 Dec 2022 11:21:20 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/linux-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</guid><description><![CDATA[查看linux系统信息 查看内核信息 zzq@Zhao:~$ uname -a Linux Zhao 5.10.16.3-microsoft-standard-WSL2 #1 SMP Fri Apr 2 22:23:49 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux zzq@Zhao:~$ cat /proc/version Linux version 5.10.16.3-microsoft-standard-WSL2 (oe-user@oe-host) (x86_64-msft-linux-gcc (GCC) 9.3.0, GNU ld (GNU Binutils) 2.34.0.20200220) #1 SMP Fri Apr 2 22:23:49 UTC 2021 查看系统的发行版本 zzq@Zhao:~$ ls /etc/*release /etc/lsb-release /etc/os-release zzq@Zhao:~$ cat /etc/os-release NAME=&#34;Ubuntu&#34; VERSION=&#34;20.04.4 LTS (Focal Fossa)&#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&#34;Ubuntu 20.04.4 LTS&#34; VERSION_ID=&#34;20.04&#34; HOME_URL=&#34;https://www.ubuntu.com/&#34; SUPPORT_URL=&#34;https://help.ubuntu.com/&#34; BUG_REPORT_URL=&#34;https://bugs.launchpad.net/ubuntu/&#34; PRIVACY_POLICY_URL=&#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal 常见目录 FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。]]></description></item><item><title>linux 杂项</title><link>https://banrenshan.github.io/blog/2022/12/linux-%E6%9D%82%E9%A1%B9/</link><pubDate>Thu, 01 Dec 2022 11:21:20 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/linux-%E6%9D%82%E9%A1%B9/</guid><description><![CDATA[VboX网络 NAT 网络地址转换Network Address Translation 是从虚拟机访问外部网络的最简单方法。通常，它 不需要在主机网络和来宾系统上进行任何配置 。因此，它是Vbox中的默认联网模式。
启用了NAT的虚拟机的行为就像是一台通过路由器连接到Internet的真实计算机。在这种情况下，路由器是Vbox网络引擎，该引擎透明地映射来往虚拟机的流量。在Vbox中，此路由器放置在每个虚拟机和主机之间。由于默认情况下虚拟机无法相互通信，因此这种隔离可最大程度地提高安全性。
虚拟机之间不能相互通信，现实中同一个路由器连接下的机器可以相互通信。
NAT模式的缺点是，就像路由器后面的专用网络一样，虚拟机是不可见的，外部Internet上的主机不能访问该虚拟机。除非设置端口转发。
虚拟机发出的网络帧由Vbox的NAT引擎接收，该引擎提取TCP/IP数据并使用主机操作系统发送出去。对于主机上的应用程序，或与主机相同网络上的另一台计算机，数据就好像是由主机上的Vbox发送出来的，使用的是主机的IP地址。Vbox监听已发送数据包的回复数据，然后重新打包并将它们重新发送到其专用网络上的虚拟机.
VM也可以访问主机的环回接口和在其上运行的网络服务。主机的环回接口可通过IP地址10.0.2.2访问。
虚拟机从集成到Vbox的DHCP服务器接收专用网络上的网络地址和配置。这样分配给虚拟机的IP地址通常与主机位于完全不同的网络上。由于可以将虚拟机的多个卡设置为使用NAT，因此第一张卡连接到专用网络10.0.2.0，第二张卡连接到网络10.0.3.0，依此类推。如果您需要更改来宾分配的IP范围,参考 Section 9.8, “Fine Tuning the Vbox NAT Engine”.
配置端口转发 由于虚拟机连接到Vbox内部的专用网络并且对主机不可见，因此主机或同一网络上的其他计算机将无法访问客户机上的网络服务。但是，就像物理路由器一样，Vbox可以通过端口转发使选定的服务对来宾外部的世界可用。这意味着Vbox侦听主机上的某些端口，并在相同或不同端口上将到达主机的所有数据包重新发送给来宾。对于主机上的应用程序或网络上的其他物理或虚拟机，看起来好像代理的服务实际上在主机上运行。
要配置端口转发，可以使用图形化的端口转发编辑器，该编辑器可在网络设置对话框中找到，用于配置为使用NAT的网络适配器。在这里，您可以将主机端口映射到来宾端口，以将网络流量路由到来宾中的特定端口。
转发低于1024的主机端口。在基于UNIX的主机(例如Linux，Oracle Solaris和Mac OS X)上，无法从非root用户运行的应用程序绑定到低于1024的端口。因此，如果您尝试配置此类端口转发，则VM将拒绝启动。
NAT网络 网络地址转换(NAT)服务的工作方式与家用路由器类似，将使用该服务的系统分组到网络中，并防止该网络外部的系统直接访问其内部的系统，但允许内部的系统相互通信并与之通信。外部系统在IPv4和IPv6上使用TCP和UDP。
网络需要设置成静态IP。
桥接网络 通过桥接网络，Vbox使用主机系统上的设备驱动程序来过滤来自物理网络适配器的数据。这使Vbox可以拦截来自物理网络的数据并将注入一些其他信息，从而有效地在软件中创建新的网络接口。当来宾使用这种新的软件接口时，它看起来像是使用网络电缆将来宾物理连接到主机系统的主机系统。主机可以通过该接口向来宾发送数据，并从中接收数据。这意味着您可以在客户机与网络的其余部分之间设置路由或桥接。
要启用桥接网络，请打开虚拟机的“设置”对话框，转到“网络”页面，然后在“附加到”字段的下拉列表中选择“桥接网络”。从页面底部的列表中选择一个主机接口，其中包含系统的物理网络接口。
内部网络 内部网络类似于桥接网络，因为VM可以直接与外界通信。但是，外部世界仅限于同一主机上连接到同一内部网络的其他VM。
即使从技术上讲，使用内部网络可以完成的所有操作也可以使用桥接网络来完成，但是内部网络具有安全性优势。在桥接网络模式下，所有流量都通过主机系统的物理接口。因此，可以将诸如Wireshark的数据包嗅探器附加到主机接口，并记录通过它的所有流量。如果出于某种原因，如果您希望同一台计算机上的两个或多个VM进行私下通信，同时对主机系统和用户隐藏其数据，则桥接网络不是一种选择。
内部网络会根据需要自动创建。没有中央配置。每个内部网络都简单地通过其名称进行标识。一旦有一个以上具有相同内部网络ID的活动虚拟网卡，Vbox支持驱动程序将自动将这些网卡连接起来并充当网络交换机。Vbox支持驱动程序实现了完整的以太网交换机，并支持广播/多播帧和混杂模式。
为了将VM的网卡连接到内部网络，请将其网络连接模式设置为Internal Networking。在Vbox图形用户界面中使用VM的“设置”对话框。在设置对话框的“网络”类别中，从网络模式的下拉列表中选择“内部网络”。从下面的下拉列表中选择一个现有内部网络的名称，或在“名称”字段中输入一个新名称。
网络需要设置成静态IP。
Host-Only网络 可以将仅主机的网络视为桥接和内部网络模式之间的混合。与桥接网络一样，虚拟机可以彼此通信，也可以与主机进行通信，就像它们通过物理以太网交换机连接一样。与内部网络一样，不需要存在物理网络接口，并且由于虚拟机未连接到物理网络接口，因此它们无法与主机外部的世界进行通信
使用仅主机网络时，Vbox在主机上创建一个新的软件接口，该接口随后出现在现有网络接口旁边。换句话说，尽管使用桥接网络，但现有物理接口用于将虚拟机连接到其中，而仅主机网络则在主机上创建新的回送接口。而且，尽管使用内部网络，但无法看到虚拟机之间的流量，但是可以拦截主机上环回接口上的流量。
仅主机网络对于预配置的虚拟设备特别有用，在预配置的虚拟设备中，多个虚拟机一起运送并旨在进行协作。例如，一个虚拟机可能包含一个Web服务器，第二个虚拟机可能包含一个数据库，并且由于它们打算互相通信，因此该设备可以指示Vbox为这两个虚拟机建立仅主机的网络。然后，第二个桥接网络会将Web服务器连接到外部，以向其提供数据，但是外部无法连接到数据库。
根据上面的概述,采用NAT和Host-only来构建虚拟机,这样虚拟机既可以上外网又可以和主机互通.构建过程如下:
1.在网络选项卡中设置网卡1为NAT 2.在网络选项卡中设置网卡2为Host-only
虚拟机网络信息
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 08:00:27:18:fd:f6 brd ff:ff:ff:ff:ff:ff inet 10.]]></description></item><item><title>linux软件和服务管理</title><link>https://banrenshan.github.io/blog/2022/12/linux%E8%BD%AF%E4%BB%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</link><pubDate>Thu, 01 Dec 2022 11:21:20 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/linux%E8%BD%AF%E4%BB%B6%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</guid><description>进程管理 在操作系统中，所有可以执行的程序与命令都会产生进程。只是有些程序和命令非常简单，如 ls 命令、touch 命令等，它们在执行完后就会结束，相应的进程也就会终结，所以我们很难捕捉到这些进程。但是还有一些程和命令，比如 httpd 进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作常驻内存进程。
某些进程会产生一些新的进程，我们把这些进程称作子进程，而把这个进程本身称作父进程。比如，我们必须正常登录到 Shell 环境中才能执行系统命令，而 Linux 的标准 Shell 是 bash。我们在 bash 当中执行了 ls 命令，那么 bash 就是父进程，而 ls 命令是在 bash 进程中产生的进程，所以 ls 进程是 bash 进程的子进程。也就是说，子进程是依赖父进程而产生的，如果父进程不存在，那么子进程也不存在了。
进程启动的方式 在 Linux 系统中，每个进程都有一个唯一的进程号（PID），方便系统识别和调度进程。通过简单地输出运行程序的程序名，就可以运行该程序，其实也就是启动了一个进程。
总体来说，启动一个进程主要有 2 种途径，分别是通过手工启动和通过调度启动（事先进行设置，根据用户要求，进程可以自行启动。
手工启动进程 手工启动进程指的是由用户输入命令直接启动一个进程，根据所启动的进程类型和性质的不同，其又可以细分为前台启动和后台启动 2 种方式。
前台启动进程 这是手工启动进程最常用的方式，因为当用户输入一个命令并运行，就已经启动了一个进程，而且是一个前台的进程，此时系统其实已经处于一个多进程的状态（一个是 Shell 进程，另一个是新启动的进程）。
假如启动一个比较耗时的进程，然后再把该进程挂起，并使用 ps 命令查看，就会看到该进程在 ps 显示列表中，例如：
[root@localhost ~]# find / -name demo.jpg &amp;lt;--在根目录下查找 demo.jpg 文件，比较耗时 #此处省略了该命令的部分输出信息 #按“CTRL+Z”组合键，即可将该进程挂起 [root@localhost ~]# ps &amp;lt;--查看正在运行的进程 PID TTY TIME CMD 2573 pts/0 00:00:00 bash 2587 pts/0 00:00:01 find 2588 pts/0 00:00:00 ps 将进程挂起，指的是将前台运行的进程放到后台，并且暂停其运行.</description></item><item><title>linux性能管理</title><link>https://banrenshan.github.io/blog/2022/12/linux%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86/</link><pubDate>Thu, 01 Dec 2022 11:21:20 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/linux%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86/</guid><description>性能指标 CPU CPU 是操作系统稳定运行的根本，CPU 的速度与性能很大一部分决定了系统整体的性能，因此 CPU 数量越多、主频越高，服务器性能也就相对越好。
但亊实也并非完全如此，目前大部分 CPU 在同一时间内只能运行一个线程，超线程的处理器可以在同一时间运行多个线程，因而可以利用处理器的超线程特性提髙系统性能。
而在 Linux 系统下，只有运行 SMP 内核才能支持超线程，但是安装的 CPU 数量越多，从超线程获得的性能上的提高就越少。另外，Linux 内核会把多核的处理器当作多个单独的 CPU 来识别，例如两颗 4 核的 CPU 在 Linux 系统下会认为是 8 颗 CPU。
注意，从性能角度来讲，两颗 4 核的 CPU 和 8 颗单核的 CPU 并不完全等价，根据权威部门得出的测试结论，前者的整体性能要低于后者 25%〜30%。
在 Linux 系统中，邮件服务器、动态 Web 服务器等应用对 CPU 性能的要求相对较高，因此对于这类应用，要把 CPU 的配置和性能放在主要位置。
内存 内存的大小也是影响 Linux 性能的一个重要的因素。内存太小，系统进程将被阻塞，应用也将变得缓慢，甚至失去响应；内存太大，会导致资源浪费。
Linux 系统采用了物理内存和虚拟内存的概念，虚拟内存虽然可以缓解物理内存的不足，但是占用过多的虚拟内存，应用程序的性能将明显下降。要保证应用程序的高性能运行，物理内存一定要足够大，但不应过大，否则会造成内存资源的浪费。
例如，在一个 32 位处理器的 Linux 操作系统上，超过 8GB 的物理内存都将被浪费。因此，要使用更大的内存，建议安装 64 位的操作系统，同时开启 Linux 的大内存内核支持。
不仅如此，由于处理器寻址范围的限制，在 32 位 Linux 操作系统上，应用程序单个进程最大只能使用 2GB 的内存。这样即使系统有更大的内存，应用程序也无法“享”用，解决的办法就是使用 64 位处理器，安装 64 位操作系统，在 64 位操作系统下，可以满足所有应用程序对内存的使用需求，几乎没有限制。</description></item><item><title>linux用户和权限</title><link>https://banrenshan.github.io/blog/2022/12/linux%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90/</link><pubDate>Thu, 01 Dec 2022 11:21:20 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/linux%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90/</guid><description><![CDATA[登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号（也就是一串数字）。
要论证 &ldquo;Linux系统不认识用户名&rdquo; 也很简单，网络上下载过 &ldquo;.tar.gz&rdquo; 或 &ldquo;.tar.bz2&rdquo; 格式的文件，解压缩之后的文件中，有时，你会发现文件拥有者的属性显示的是一串数字，这串数字就是用户的 ID（UID）号。之所以没有显示出用户名称，是因为找不到UID对应的用户。
Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和组 ID（Group ID，简称 GID），这与文件有拥有者和拥有群组两种属性相对应。
管理用户的文件 创建用户的时候，会默认分配与用户同名的用户组，这个创建时自动分配的用户组叫做初始组。 后面又给该用户添加的其他用户组，叫做附加组。
每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 /etc/passwd 和 /etc/group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来。
/etc/passwd 文件 root@zzq:~# cat /etc/passwd root❌0:0:root:/root:/bin/bash daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin bin❌2:2:bin:/bin:/usr/sbin/nologin sys❌3:3:sys:/dev:/usr/sbin/nologin sync❌4:65534:sync:/bin:/bin/sync 这些用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为系统用户或伪用户。系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。
不仅如此，每行用户信息都以 &ldquo;：&rdquo; 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：
用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell
密码 &ldquo;x&rdquo; 表示此用户设有密码，但不是真正的密码，真正的密码保存在 /etc/shadow 文件中。此文件只有 root 用户可以浏览和操作，这样就最大限度地保证了密码的安全。需要注意的是，虽然 &ldquo;x&rdquo; 并不表示真正的密码，但也不能删除，如果删除了 &ldquo;x&rdquo;，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登陆
UID UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。 实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份。]]></description></item><item><title>Systemd服务管理</title><link>https://banrenshan.github.io/blog/2022/12/systemd%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</link><pubDate>Thu, 01 Dec 2022 11:21:20 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/systemd%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</guid><description>历史上Linux的启动一直采用init进程，即下面的命令用来启动服务：
$ sudo /etc/init.d/apache2 start #或者 $ service apache2 start 这种方法有两个缺点:
启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。
启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。
Systemd就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案，根据Linux惯例，字母d是守护进程（daemon）的缩写，Systemd这个名字的含义，就是它要守护整个系统。
概述 使用了Systemd，就不需要再用init了。Systemd取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。
Systemd的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的Unix哲学。
管理命令 Systemd并不是一个命令，而是一组命令，涉及到系统管理的方方面面。
systemctl 是Systemd的主命令，用于管理系统 #重启系统 $ sudo systemctl reboot #关闭系统，切断电源 $ sudo systemctl poweroff #CPU停止工作 $ sudo systemctl halt #暂停系统 $ sudo systemctl suspend #让系统进入冬眠状态 $ sudo systemctl hibernate #让系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep #启动进入救援状态（单用户状态） $ sudo systemctl rescue systemd-analyze 命令用于查看启动耗时 #查看启动耗时 [root@k8s ~]# systemd-analyze Startup finished in 2.</description></item><item><title>shell</title><link>https://banrenshan.github.io/blog/2022/12/shell/</link><pubDate>Thu, 01 Dec 2022 11:01:29 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/12/shell/</guid><description>环境变量 在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。
值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。
我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下：
[root@localhost ~]# env ORBIT_SOCKETDIR=/tmp/orbit-root HOSTNAME=livecd.centos GIO_LAUNCHED_DESKTOP_FILE_PID=2065 TERM=xterm SHELL=/bin/bash ...... 下面是几个常用的环境变量：
环境变量名称 作用 HOME 用户的主目录（也称家目录） SHELL 用户使用的 Shell 解释器名称 PATH 定义命令行解释器搜索用户执行命令的路径 EDITOR 用户默认的文本解释器 RANDOM 生成一个随机数字 LANG 系统语言、语系名称 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 PS1 Bash解释器的提示符 MAIL 邮件保存路径 Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。
例如，使用下述命令来查看 HOME 变量在不同用户身份下都有哪些值：
[root@localhost ~]# echo $HOME /root [root@localhost ~]# su - user1 &amp;lt;--切换到 user1 用户身份 [user1@localhost ~]$ echo $HOME /home/user1 其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 WORKDIR 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下：</description></item><item><title>linux常用命令</title><link>https://banrenshan.github.io/blog/2022/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Wed, 30 Nov 2022 16:44:17 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>软连接 ext4 文件系统 如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统（Linux 文件系统）是如何工作的。而我们的 Linux 目前使用的是 ext4 文件系统。如果用一张示意图来描述 ext4 文件系统：
ext4 文件系统会把分区主要分为两大部分（暂时不提超级块）：小部分用于保存文件的 inode (i 节点）信息；剩余的大部分用于保存 block 信息。
inode 的默认大小为 128 Byte，用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、真正保存文件数据的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。
block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。
由此，我们可以知道以下 2 个重要的信息：
每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；
如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；
了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。
ln 命令 ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种：</description></item><item><title>Unbutu 使用</title><link>https://banrenshan.github.io/blog/2022/11/unbutu-%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 27 Nov 2022 19:21:30 +0000</pubDate><guid>https://banrenshan.github.io/blog/2022/11/unbutu-%E4%BD%BF%E7%94%A8/</guid><description>deb包 查看默认安装位置 查看deb包的安装位置：
sudo dpkg-deb -c jdk-19_linux-x64_bin.deb 安装deb包 sudo apt-get install -y adduser libfontconfig1 wget https://dl.grafana.com/enterprise/release/grafana-enterprise_9.2.4_amd64.deb sudo dpkg -i grafana-enterprise_9.2.4_amd64.deb</description></item></channel></rss>